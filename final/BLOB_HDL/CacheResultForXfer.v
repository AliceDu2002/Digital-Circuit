// -------------------------------------------------------------
// 
// File Name: C:\Users\team06\Documents\MATLAB\Examples\R2022b\visionhdl\BlobAnalysisExample\verilog_hdl\BlobAnalysisHDL\CacheResultForXfer.v
// Created: 2022-12-23 11:30:02
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: CacheResultForXfer
// Source Path: BlobAnalysisHDL/BlobDetector/CacheResultForXfer
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module CacheResultForXfer
          (clk,
           reset,
           enb,
           x_i,
           y_i,
           area_i,
           bbox_i,
           valid_i,
           last_i,
           getidx_i,
           x_o,
           y_o,
           area_o,
           bbx1_o,
           bby1_o,
           bbx2_o,
           bby2_o);


  input   clk;
  input   reset;
  input   enb;
  input   [15:0] x_i;  // ufix16_En5
  input   [15:0] y_i;  // ufix16_En5
  input   [16:0] area_i;  // ufix17
  input   [33:0] bbox_i;  // ufix34
  input   valid_i;
  input   last_i;
  input   [9:0] getidx_i;  // ufix10
  output  [15:0] x_o;  // uint16
  output  [15:0] y_o;  // uint16
  output  [16:0] area_o;  // ufix17
  output  [8:0] bbx1_o;  // ufix9
  output  [7:0] bby1_o;  // uint8
  output  [8:0] bbx2_o;  // ufix9
  output  [7:0] bby2_o;  // uint8


  reg [16:0] delayMatch_reg [0:10];  // ufix17 [11]
  wire [16:0] delayMatch_reg_next [0:10];  // ufix17 [11]
  wire [16:0] area_i_1;  // ufix17
  reg [33:0] delayMatch1_reg [0:10];  // ufix34 [11]
  wire [33:0] delayMatch1_reg_next [0:10];  // ufix34 [11]
  wire [33:0] bbox_i_1;  // ufix34
  wire [82:0] y;  // ufix83
  wire [82:0] y_1;  // ufix83
  wire [9:0] count_step;  // ufix10
  wire [9:0] count_reset;  // ufix10
  reg [9:0] HDL_Counter_out1;  // ufix10
  wire [9:0] count;  // ufix10
  wire [9:0] count_1;  // ufix10
  wire [9:0] count_2;  // ufix10
  reg [9:0] delayMatch2_reg [0:10];  // ufix10 [11]
  wire [9:0] delayMatch2_reg_next [0:10];  // ufix10 [11]
  wire [9:0] HDL_Counter_out1_1;  // ufix10
  reg  [0:10] delayMatch3_reg;  // ufix1 [11]
  wire [0:10] delayMatch3_reg_next;  // ufix1 [11]
  wire valid_i_1;
  reg [9:0] delayMatch4_reg [0:10];  // ufix10 [11]
  wire [9:0] delayMatch4_reg_next [0:10];  // ufix10 [11]
  wire [9:0] getidx_i_1;  // ufix10
  wire [82:0] Simple_Dual_Port_RAM_System_out1;  // ufix83
  wire [15:0] Bit_Slice_out1;  // uint16
  wire [15:0] Bit_Slice1_out1;  // uint16
  wire [16:0] Bit_Slice2_out1;  // ufix17
  wire [33:0] Bit_Slice6_out1;  // ufix34
  wire [8:0] X1;  // ufix9
  wire [7:0] Y1;  // uint8
  wire [8:0] X2;  // ufix9
  wire [7:0] Y2;  // uint8


  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 17'b00000000000000000;
        delayMatch_reg[1] <= 17'b00000000000000000;
        delayMatch_reg[2] <= 17'b00000000000000000;
        delayMatch_reg[3] <= 17'b00000000000000000;
        delayMatch_reg[4] <= 17'b00000000000000000;
        delayMatch_reg[5] <= 17'b00000000000000000;
        delayMatch_reg[6] <= 17'b00000000000000000;
        delayMatch_reg[7] <= 17'b00000000000000000;
        delayMatch_reg[8] <= 17'b00000000000000000;
        delayMatch_reg[9] <= 17'b00000000000000000;
        delayMatch_reg[10] <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
          delayMatch_reg[5] <= delayMatch_reg_next[5];
          delayMatch_reg[6] <= delayMatch_reg_next[6];
          delayMatch_reg[7] <= delayMatch_reg_next[7];
          delayMatch_reg[8] <= delayMatch_reg_next[8];
          delayMatch_reg[9] <= delayMatch_reg_next[9];
          delayMatch_reg[10] <= delayMatch_reg_next[10];
        end
      end
    end

  assign area_i_1 = delayMatch_reg[10];
  assign delayMatch_reg_next[0] = area_i;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];
  assign delayMatch_reg_next[5] = delayMatch_reg[4];
  assign delayMatch_reg_next[6] = delayMatch_reg[5];
  assign delayMatch_reg_next[7] = delayMatch_reg[6];
  assign delayMatch_reg_next[8] = delayMatch_reg[7];
  assign delayMatch_reg_next[9] = delayMatch_reg[8];
  assign delayMatch_reg_next[10] = delayMatch_reg[9];



  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        delayMatch1_reg[0] <= 34'h000000000;
        delayMatch1_reg[1] <= 34'h000000000;
        delayMatch1_reg[2] <= 34'h000000000;
        delayMatch1_reg[3] <= 34'h000000000;
        delayMatch1_reg[4] <= 34'h000000000;
        delayMatch1_reg[5] <= 34'h000000000;
        delayMatch1_reg[6] <= 34'h000000000;
        delayMatch1_reg[7] <= 34'h000000000;
        delayMatch1_reg[8] <= 34'h000000000;
        delayMatch1_reg[9] <= 34'h000000000;
        delayMatch1_reg[10] <= 34'h000000000;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
          delayMatch1_reg[3] <= delayMatch1_reg_next[3];
          delayMatch1_reg[4] <= delayMatch1_reg_next[4];
          delayMatch1_reg[5] <= delayMatch1_reg_next[5];
          delayMatch1_reg[6] <= delayMatch1_reg_next[6];
          delayMatch1_reg[7] <= delayMatch1_reg_next[7];
          delayMatch1_reg[8] <= delayMatch1_reg_next[8];
          delayMatch1_reg[9] <= delayMatch1_reg_next[9];
          delayMatch1_reg[10] <= delayMatch1_reg_next[10];
        end
      end
    end

  assign bbox_i_1 = delayMatch1_reg[10];
  assign delayMatch1_reg_next[0] = bbox_i;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];
  assign delayMatch1_reg_next[3] = delayMatch1_reg[2];
  assign delayMatch1_reg_next[4] = delayMatch1_reg[3];
  assign delayMatch1_reg_next[5] = delayMatch1_reg[4];
  assign delayMatch1_reg_next[6] = delayMatch1_reg[5];
  assign delayMatch1_reg_next[7] = delayMatch1_reg[6];
  assign delayMatch1_reg_next[8] = delayMatch1_reg[7];
  assign delayMatch1_reg_next[9] = delayMatch1_reg[8];
  assign delayMatch1_reg_next[10] = delayMatch1_reg[9];



  assign y = {x_i, y_i, area_i_1, bbox_i_1};



  assign y_1 = y;

  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  assign count_step = 10'b0000000001;



  assign count_reset = 10'b0000000000;



  assign count = HDL_Counter_out1 + count_step;



  assign count_1 = (valid_i == 1'b0 ? HDL_Counter_out1 :
              count);



  assign count_2 = (last_i == 1'b0 ? count_1 :
              count_reset);



  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= count_2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : delayMatch2_process
      if (reset == 1'b1) begin
        delayMatch2_reg[0] <= 10'b0000000000;
        delayMatch2_reg[1] <= 10'b0000000000;
        delayMatch2_reg[2] <= 10'b0000000000;
        delayMatch2_reg[3] <= 10'b0000000000;
        delayMatch2_reg[4] <= 10'b0000000000;
        delayMatch2_reg[5] <= 10'b0000000000;
        delayMatch2_reg[6] <= 10'b0000000000;
        delayMatch2_reg[7] <= 10'b0000000000;
        delayMatch2_reg[8] <= 10'b0000000000;
        delayMatch2_reg[9] <= 10'b0000000000;
        delayMatch2_reg[10] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= delayMatch2_reg_next[0];
          delayMatch2_reg[1] <= delayMatch2_reg_next[1];
          delayMatch2_reg[2] <= delayMatch2_reg_next[2];
          delayMatch2_reg[3] <= delayMatch2_reg_next[3];
          delayMatch2_reg[4] <= delayMatch2_reg_next[4];
          delayMatch2_reg[5] <= delayMatch2_reg_next[5];
          delayMatch2_reg[6] <= delayMatch2_reg_next[6];
          delayMatch2_reg[7] <= delayMatch2_reg_next[7];
          delayMatch2_reg[8] <= delayMatch2_reg_next[8];
          delayMatch2_reg[9] <= delayMatch2_reg_next[9];
          delayMatch2_reg[10] <= delayMatch2_reg_next[10];
        end
      end
    end

  assign HDL_Counter_out1_1 = delayMatch2_reg[10];
  assign delayMatch2_reg_next[0] = HDL_Counter_out1;
  assign delayMatch2_reg_next[1] = delayMatch2_reg[0];
  assign delayMatch2_reg_next[2] = delayMatch2_reg[1];
  assign delayMatch2_reg_next[3] = delayMatch2_reg[2];
  assign delayMatch2_reg_next[4] = delayMatch2_reg[3];
  assign delayMatch2_reg_next[5] = delayMatch2_reg[4];
  assign delayMatch2_reg_next[6] = delayMatch2_reg[5];
  assign delayMatch2_reg_next[7] = delayMatch2_reg[6];
  assign delayMatch2_reg_next[8] = delayMatch2_reg[7];
  assign delayMatch2_reg_next[9] = delayMatch2_reg[8];
  assign delayMatch2_reg_next[10] = delayMatch2_reg[9];



  always @(posedge clk or posedge reset)
    begin : delayMatch3_process
      if (reset == 1'b1) begin
        delayMatch3_reg[0] <= 1'b0;
        delayMatch3_reg[1] <= 1'b0;
        delayMatch3_reg[2] <= 1'b0;
        delayMatch3_reg[3] <= 1'b0;
        delayMatch3_reg[4] <= 1'b0;
        delayMatch3_reg[5] <= 1'b0;
        delayMatch3_reg[6] <= 1'b0;
        delayMatch3_reg[7] <= 1'b0;
        delayMatch3_reg[8] <= 1'b0;
        delayMatch3_reg[9] <= 1'b0;
        delayMatch3_reg[10] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch3_reg[0] <= delayMatch3_reg_next[0];
          delayMatch3_reg[1] <= delayMatch3_reg_next[1];
          delayMatch3_reg[2] <= delayMatch3_reg_next[2];
          delayMatch3_reg[3] <= delayMatch3_reg_next[3];
          delayMatch3_reg[4] <= delayMatch3_reg_next[4];
          delayMatch3_reg[5] <= delayMatch3_reg_next[5];
          delayMatch3_reg[6] <= delayMatch3_reg_next[6];
          delayMatch3_reg[7] <= delayMatch3_reg_next[7];
          delayMatch3_reg[8] <= delayMatch3_reg_next[8];
          delayMatch3_reg[9] <= delayMatch3_reg_next[9];
          delayMatch3_reg[10] <= delayMatch3_reg_next[10];
        end
      end
    end

  assign valid_i_1 = delayMatch3_reg[10];
  assign delayMatch3_reg_next[0] = valid_i;
  assign delayMatch3_reg_next[1] = delayMatch3_reg[0];
  assign delayMatch3_reg_next[2] = delayMatch3_reg[1];
  assign delayMatch3_reg_next[3] = delayMatch3_reg[2];
  assign delayMatch3_reg_next[4] = delayMatch3_reg[3];
  assign delayMatch3_reg_next[5] = delayMatch3_reg[4];
  assign delayMatch3_reg_next[6] = delayMatch3_reg[5];
  assign delayMatch3_reg_next[7] = delayMatch3_reg[6];
  assign delayMatch3_reg_next[8] = delayMatch3_reg[7];
  assign delayMatch3_reg_next[9] = delayMatch3_reg[8];
  assign delayMatch3_reg_next[10] = delayMatch3_reg[9];



  always @(posedge clk or posedge reset)
    begin : delayMatch4_process
      if (reset == 1'b1) begin
        delayMatch4_reg[0] <= 10'b0000000000;
        delayMatch4_reg[1] <= 10'b0000000000;
        delayMatch4_reg[2] <= 10'b0000000000;
        delayMatch4_reg[3] <= 10'b0000000000;
        delayMatch4_reg[4] <= 10'b0000000000;
        delayMatch4_reg[5] <= 10'b0000000000;
        delayMatch4_reg[6] <= 10'b0000000000;
        delayMatch4_reg[7] <= 10'b0000000000;
        delayMatch4_reg[8] <= 10'b0000000000;
        delayMatch4_reg[9] <= 10'b0000000000;
        delayMatch4_reg[10] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          delayMatch4_reg[0] <= delayMatch4_reg_next[0];
          delayMatch4_reg[1] <= delayMatch4_reg_next[1];
          delayMatch4_reg[2] <= delayMatch4_reg_next[2];
          delayMatch4_reg[3] <= delayMatch4_reg_next[3];
          delayMatch4_reg[4] <= delayMatch4_reg_next[4];
          delayMatch4_reg[5] <= delayMatch4_reg_next[5];
          delayMatch4_reg[6] <= delayMatch4_reg_next[6];
          delayMatch4_reg[7] <= delayMatch4_reg_next[7];
          delayMatch4_reg[8] <= delayMatch4_reg_next[8];
          delayMatch4_reg[9] <= delayMatch4_reg_next[9];
          delayMatch4_reg[10] <= delayMatch4_reg_next[10];
        end
      end
    end

  assign getidx_i_1 = delayMatch4_reg[10];
  assign delayMatch4_reg_next[0] = getidx_i;
  assign delayMatch4_reg_next[1] = delayMatch4_reg[0];
  assign delayMatch4_reg_next[2] = delayMatch4_reg[1];
  assign delayMatch4_reg_next[3] = delayMatch4_reg[2];
  assign delayMatch4_reg_next[4] = delayMatch4_reg[3];
  assign delayMatch4_reg_next[5] = delayMatch4_reg[4];
  assign delayMatch4_reg_next[6] = delayMatch4_reg[5];
  assign delayMatch4_reg_next[7] = delayMatch4_reg[6];
  assign delayMatch4_reg_next[8] = delayMatch4_reg[7];
  assign delayMatch4_reg_next[9] = delayMatch4_reg[8];
  assign delayMatch4_reg_next[10] = delayMatch4_reg[9];



  SimpleDualPortRAM_generic_block2 #(.AddrWidth(10),
                                     .DataWidth(83)
                                     )
                                   u_Simple_Dual_Port_RAM_System (.clk(clk),
                                                                  .enb(enb),
                                                                  .wr_din(y_1),
                                                                  .wr_addr(HDL_Counter_out1_1),
                                                                  .wr_en(valid_i_1),
                                                                  .rd_addr(getidx_i_1),
                                                                  .rd_dout(Simple_Dual_Port_RAM_System_out1)
                                                                  );

  assign Bit_Slice_out1 = Simple_Dual_Port_RAM_System_out1[82:67];



  assign x_o = Bit_Slice_out1;

  assign Bit_Slice1_out1 = Simple_Dual_Port_RAM_System_out1[66:51];



  assign y_o = Bit_Slice1_out1;

  assign Bit_Slice2_out1 = Simple_Dual_Port_RAM_System_out1[50:34];



  assign area_o = Bit_Slice2_out1;

  assign Bit_Slice6_out1 = Simple_Dual_Port_RAM_System_out1[33:0];



  splitBBox u_splitBBox (.In1(Bit_Slice6_out1),  // ufix34
                         .X1(X1),  // ufix9
                         .Y1(Y1),  // uint8
                         .X2(X2),  // ufix9
                         .Y2(Y2)  // uint8
                         );

  assign bbx1_o = X1;

  assign bby1_o = Y1;

  assign bbx2_o = X2;

  assign bby2_o = Y2;

endmodule  // CacheResultForXfer

