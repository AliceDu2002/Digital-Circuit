// -------------------------------------------------------------
// 
// File Name: C:\Users\team06\Documents\MATLAB\Examples\R2022b\visionhdl\BlobAnalysisExample\verilog_hdl\BlobAnalysisHDL\cca.v
// Created: 2022-12-23 11:30:02
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: cca
// Source Path: BlobAnalysisHDL/BlobDetector/CCA_Algorithm/cca
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module cca
          (clk,
           reset,
           enb,
           BW,
           CtrlIn_hStart,
           CtrlIn_hEnd,
           CtrlIn_vStart,
           CtrlIn_vEnd,
           CtrlIn_valid,
           Rst,
           Xpos,
           Ypos,
           labelpixout,
           labelctrlout_hStart,
           labelctrlout_hEnd,
           labelctrlout_vStart,
           labelctrlout_vEnd,
           labelctrlout_valid,
           x_o,
           y_o,
           area_o,
           valid_o,
           last_o,
           num_o,
           bbox_o);


  input   clk;
  input   reset;
  input   enb;
  input   BW;
  input   CtrlIn_hStart;
  input   CtrlIn_hEnd;
  input   CtrlIn_vStart;
  input   CtrlIn_vEnd;
  input   CtrlIn_valid;
  input   Rst;
  input   [8:0] Xpos;  // ufix9
  input   [7:0] Ypos;  // uint8
  output  [9:0] labelpixout;  // ufix10
  output  labelctrlout_hStart;
  output  labelctrlout_hEnd;
  output  labelctrlout_vStart;
  output  labelctrlout_vEnd;
  output  labelctrlout_valid;
  output  [55:0] x_o;  // ufix56_En30
  output  [55:0] y_o;  // ufix56_En30
  output  [16:0] area_o;  // ufix17
  output  valid_o;
  output  last_o;
  output  [15:0] num_o;  // uint16
  output  [33:0] bbox_o;  // ufix34


  reg  [0:1] Delay4_reg;  // ufix1 [2]
  wire [0:1] Delay4_reg_next;  // ufix1 [2]
  wire pixin;
  reg  [0:1] alpha_reg;  // ufix1 [2]
  wire [0:1] alpha_reg_next;  // ufix1 [2]
  wire ctrlIn_hStart_1;
  reg  [0:1] alpha_reg_1;  // ufix1 [2]
  wire [0:1] alpha_reg_next_1;  // ufix1 [2]
  wire ctrlIn_hEnd_1;
  reg  [0:1] alpha_reg_2;  // ufix1 [2]
  wire [0:1] alpha_reg_next_2;  // ufix1 [2]
  wire ctrlIn_vStart_1;
  reg  [0:1] alpha_reg_3;  // ufix1 [2]
  wire [0:1] alpha_reg_next_3;  // ufix1 [2]
  wire ctrlIn_vEnd_1;
  reg  [0:1] alpha_reg_4;  // ufix1 [2]
  wire [0:1] alpha_reg_next_4;  // ufix1 [2]
  wire ctrlIn_valid_1;
  wire hStart;
  wire vStart;
  wire AND1_out1;
  wire Hold_Signal1_out1;
  wire Subsystem_out1;
  wire OR3_out1;
  reg [8:0] Delay1_reg [0:2];  // ufix9 [3]
  wire [8:0] Delay1_reg_next [0:2];  // ufix9 [3]
  wire [8:0] wraddr;  // ufix9
  wire valid;
  reg  wren;
  wire [9:0] Constant2_out1;  // ufix10
  wire [9:0] right;  // ufix10
  wire [9:0] blobacc;  // ufix10
  reg [9:0] center;  // ufix10
  reg [9:0] left;  // ufix10
  wire [9:0] blobacc_1;  // ufix10
  wire [9:0] newLabel;  // ufix10
  wire [9:0] blobacc_2;  // ufix10
  wire [31:0] mergeIndxs;  // uint32
  wire [10:0] maxIdx;  // ufix11
  reg [9:0] wren_1;  // ufix10
  wire hEnd;
  wire [9:0] Merge_out1;  // ufix10
  wire mrgEn;
  wire SingleEdgeDetectorL2H2_out1;
  reg  AccEn;
  reg  AccEn_1;
  wire OR_out1;
  wire [23:0] wraddr_dtc;  // ufix24
  wire vEnd;
  wire Constant_out1;  // ufix1
  wire Constant1_out1;  // ufix1
  wire rdreset;
  wire OR1_out1;
  wire [9:0] blobIdx;  // ufix10
  wire [9:0] blobacc_3;  // ufix10
  wire OR2_out1;
  wire blobacc_4;  // ufix1
  wire above;  // ufix1
  wire valid_1;
  wire [15:0] numFnd;  // uint16
  wire [10:0] Relational_Operator_1_1;  // ufix11
  wire Relational_Operator_relop1;
  wire Compare_To_Zero1_out1;
  wire AND_out1;
  reg  reset_1;
  wire Hold_Signal_out1;
  reg  reset_2;
  wire reset_3;
  wire Compare_To_Zero_out1;
  wire one1_out1;
  wire mergeAccEn;
  wire [9:0] preblobidx;  // ufix10
  reg [9:0] Delay10_reg [0:1];  // ufix10 [2]
  wire [9:0] Delay10_reg_next [0:1];  // ufix10 [2]
  wire [9:0] wraddr_1;  // ufix10
  wire [9:0] blobacc_5;  // ufix10
  reg [9:0] pushBadIdx;  // ufix10
  wire [9:0] blobacc_6;  // ufix10
  wire [23:0] xAdd;  // ufix24
  wire [23:0] xacc;  // ufix24
  reg [7:0] Delay6_reg [0:2];  // ufix8 [3]
  wire [7:0] Delay6_reg_next [0:2];  // ufix8 [3]
  wire [7:0] wraddr_2;  // uint8
  wire [23:0] wraddr_dtc_1;  // ufix24
  wire [23:0] yAdd;  // ufix24
  wire [23:0] yacc;  // ufix24
  wire [16:0] one_out1;  // ufix17
  wire [16:0] area;  // ufix17
  wire [16:0] nptacc;  // ufix17
  wire [55:0] xpos_1;  // ufix56_En30
  wire [55:0] ypos_1;  // ufix56_En30
  wire [33:0] y;  // ufix34
  wire [33:0] area_1;  // ufix34
  wire [33:0] bboxacc;  // ufix34
  wire SingleEdgeDetectorL2H1_out1;
  reg  [0:1] Delay7_reg;  // ufix1 [2]
  wire [0:1] Delay7_reg_next;  // ufix1 [2]
  wire last_o_1;
  wire [68:0] mergedInput;  // ufix69
  reg [68:0] mergedDelay_regin;  // ufix69
  reg [4:0] mergedDelay_waddr;  // ufix5
  wire mergedDelay_wrenb;  // ufix1
  reg [4:0] mergedDelay_raddr;  // ufix5
  wire [68:0] mergedDelay_regout;  // ufix69
  reg [68:0] mergedOutput;  // ufix69
  wire [16:0] slicedInput;  // ufix17
  wire slicedInput_1;  // ufix1
  wire Integer_Delay3_out1;
  wire slicedInput_2;  // ufix1
  wire Integer_Delay2_out1;
  wire [15:0] slicedInput_3;  // ufix16
  wire [15:0] Integer_Delay5_out1;  // uint16
  wire [33:0] slicedInput_4;  // ufix34


  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg[0] <= 1'b0;
        Delay4_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= Delay4_reg_next[0];
          Delay4_reg[1] <= Delay4_reg_next[1];
        end
      end
    end

  assign pixin = Delay4_reg[1];
  assign Delay4_reg_next[0] = BW;
  assign Delay4_reg_next[1] = Delay4_reg[0];



  always @(posedge clk or posedge reset)
    begin : c_process
      if (reset == 1'b1) begin
        alpha_reg[0] <= 1'b0;
        alpha_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg[0] <= alpha_reg_next[0];
          alpha_reg[1] <= alpha_reg_next[1];
        end
      end
    end

  assign ctrlIn_hStart_1 = alpha_reg[1];
  assign alpha_reg_next[0] = CtrlIn_hStart;
  assign alpha_reg_next[1] = alpha_reg[0];



  always @(posedge clk or posedge reset)
    begin : c_1_process
      if (reset == 1'b1) begin
        alpha_reg_1[0] <= 1'b0;
        alpha_reg_1[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_1[0] <= alpha_reg_next_1[0];
          alpha_reg_1[1] <= alpha_reg_next_1[1];
        end
      end
    end

  assign ctrlIn_hEnd_1 = alpha_reg_1[1];
  assign alpha_reg_next_1[0] = CtrlIn_hEnd;
  assign alpha_reg_next_1[1] = alpha_reg_1[0];



  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        alpha_reg_2[0] <= 1'b0;
        alpha_reg_2[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_2[0] <= alpha_reg_next_2[0];
          alpha_reg_2[1] <= alpha_reg_next_2[1];
        end
      end
    end

  assign ctrlIn_vStart_1 = alpha_reg_2[1];
  assign alpha_reg_next_2[0] = CtrlIn_vStart;
  assign alpha_reg_next_2[1] = alpha_reg_2[0];



  always @(posedge clk or posedge reset)
    begin : c_3_process
      if (reset == 1'b1) begin
        alpha_reg_3[0] <= 1'b0;
        alpha_reg_3[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_3[0] <= alpha_reg_next_3[0];
          alpha_reg_3[1] <= alpha_reg_next_3[1];
        end
      end
    end

  assign ctrlIn_vEnd_1 = alpha_reg_3[1];
  assign alpha_reg_next_3[0] = CtrlIn_vEnd;
  assign alpha_reg_next_3[1] = alpha_reg_3[0];



  always @(posedge clk or posedge reset)
    begin : c_4_process
      if (reset == 1'b1) begin
        alpha_reg_4[0] <= 1'b0;
        alpha_reg_4[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_4[0] <= alpha_reg_next_4[0];
          alpha_reg_4[1] <= alpha_reg_next_4[1];
        end
      end
    end

  assign ctrlIn_valid_1 = alpha_reg_4[1];
  assign alpha_reg_next_4[0] = CtrlIn_valid;
  assign alpha_reg_next_4[1] = alpha_reg_4[0];



  assign hStart = ctrlIn_hStart_1;

  assign vStart = ctrlIn_vStart_1;

  assign AND1_out1 = hStart & vStart;



  Hold_Signal1 u_Hold_Signal1 (.clk(clk),
                               .reset(reset),
                               .enb(enb),
                               .triggerStart(AND1_out1),
                               .triggerEnd(ctrlIn_hEnd_1),
                               .Signal(Hold_Signal1_out1)
                               );

  Subsystem u_Subsystem (.clk(clk),
                         .reset(reset),
                         .enb(enb),
                         .alphahStart(ctrlIn_hStart_1),
                         .alphahEnd(ctrlIn_hEnd_1),
                         .Out1(Subsystem_out1)
                         );

  assign OR3_out1 = Hold_Signal1_out1 | Subsystem_out1;



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg[0] <= 9'b000000000;
        Delay1_reg[1] <= 9'b000000000;
        Delay1_reg[2] <= 9'b000000000;
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Delay1_reg_next[0];
          Delay1_reg[1] <= Delay1_reg_next[1];
          Delay1_reg[2] <= Delay1_reg_next[2];
        end
      end
    end

  assign wraddr = Delay1_reg[2];
  assign Delay1_reg_next[0] = Xpos;
  assign Delay1_reg_next[1] = Delay1_reg[0];
  assign Delay1_reg_next[2] = Delay1_reg[1];



  assign valid = ctrlIn_valid_1;

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        wren <= 1'b0;
      end
      else begin
        if (enb) begin
          wren <= valid;
        end
      end
    end



  assign Constant2_out1 = 10'b0000000000;



  assign blobacc = (OR3_out1 == 1'b0 ? right :
              Constant2_out1);



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        left <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          left <= center;
        end
      end
    end



  assign blobacc_1 = (OR3_out1 == 1'b0 ? left :
              Constant2_out1);



  SimpleDualPortRAM_generic_block1 #(.AddrWidth(9),
                                     .DataWidth(10)
                                     )
                                   u_Dual_Port_RAM_System (.clk(clk),
                                                           .enb(enb),
                                                           .wr_din(newLabel),
                                                           .wr_addr(wraddr),
                                                           .wr_en(wren),
                                                           .rd_addr(Xpos),
                                                           .rd_dout(right)
                                                           );

  always @(posedge clk or posedge reset)
    begin : Delay16_process
      if (reset == 1'b1) begin
        center <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          center <= right;
        end
      end
    end



  assign blobacc_2 = (OR3_out1 == 1'b0 ? center :
              Constant2_out1);



  labelandmerge u_labelandmerge (.clk(clk),
                                 .reset(reset),
                                 .enb(enb),
                                 .pixIn(pixin),
                                 .ctrlIn_hStart(ctrlIn_hStart_1),
                                 .ctrlIn_hEnd(ctrlIn_hEnd_1),
                                 .ctrlIn_vStart(ctrlIn_vStart_1),
                                 .ctrlIn_vEnd(ctrlIn_vEnd_1),
                                 .ctrlIn_valid(ctrlIn_valid_1),
                                 .labelAbove(blobacc_2),  // ufix10
                                 .labelAboveLeft(blobacc_1),  // ufix10
                                 .labelAboveRight(blobacc),  // ufix10
                                 .rst(Rst),
                                 .newLabel(newLabel),  // ufix10
                                 .mergeIndxs(mergeIndxs),  // uint32
                                 .maxIdx(maxIdx)  // ufix11
                                 );

  always @(posedge clk or posedge reset)
    begin : Delay17_process
      if (reset == 1'b1) begin
        wren_1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          wren_1 <= newLabel;
        end
      end
    end



  assign labelpixout = wren_1;

  assign labelctrlout_hStart = ctrlIn_hStart_1;

  assign labelctrlout_hEnd = ctrlIn_hEnd_1;

  assign labelctrlout_vStart = ctrlIn_vStart_1;

  assign labelctrlout_vEnd = ctrlIn_vEnd_1;

  assign labelctrlout_valid = ctrlIn_valid_1;

  assign hEnd = ctrlIn_hEnd_1;

  Merge u_Merge (.clk(clk),
                 .reset(reset),
                 .enb(enb),
                 .alphahStart(ctrlIn_hStart_1),
                 .alphahEnd(hEnd),
                 .mergePush(mergeIndxs),  // uint32
                 .mergeIndex(Merge_out1),  // ufix10
                 .mergeEn(mrgEn)
                 );

  SingleEdgeDetectorL2H1 u_SingleEdgeDetectorL2H2 (.clk(clk),
                                                   .reset(reset),
                                                   .enb(enb),
                                                   .sync(mrgEn),
                                                   .Out1(SingleEdgeDetectorL2H2_out1)
                                                   );

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        AccEn <= 1'b0;
      end
      else begin
        if (enb) begin
          AccEn <= SingleEdgeDetectorL2H2_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        AccEn_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          AccEn_1 <= AccEn;
        end
      end
    end



  assign OR_out1 = AccEn_1 | mrgEn;



  assign wraddr_dtc = {15'b0, wraddr};



  assign vEnd = ctrlIn_vEnd_1;

  assign Constant_out1 = 1'b1;



  assign Constant1_out1 = 1'b0;



  assign OR1_out1 = mrgEn | rdreset;



  assign blobacc_3 = (rdreset == 1'b0 ? Merge_out1 :
              blobIdx);



  assign OR2_out1 = SingleEdgeDetectorL2H2_out1 | rdreset;



  assign blobacc_4 = (OR2_out1 == 1'b0 ? Constant_out1 :
              Constant1_out1);



  SimpleDualPortRAM_singlebit #(.AddrWidth(10),
                                .DataWidth(1)
                                )
                              u_mergedblobs (.clk(clk),
                                             .enb(enb),
                                             .wr_din(blobacc_4),  // ufix1
                                             .wr_addr(blobacc_3),
                                             .wr_en(OR1_out1),
                                             .rd_addr(blobIdx),
                                             .rd_dout(above)  // ufix1
                                             );

  ReadBlobs u_ReadBlobs (.clk(clk),
                         .reset(reset),
                         .enb(enb),
                         .start(vEnd),
                         .maxIdx(maxIdx),  // ufix11
                         .skipidx(above),  // ufix1
                         .blobIdx(blobIdx),  // ufix10
                         .valid(valid_1),
                         .rdreset(rdreset),
                         .numFnd(numFnd)  // uint16
                         );

  assign Relational_Operator_1_1 = {1'b0, blobIdx};
  assign Relational_Operator_relop1 = Relational_Operator_1_1 >= maxIdx;



  assign Compare_To_Zero1_out1 = maxIdx != 11'b00000000000;



  assign AND_out1 = Relational_Operator_relop1 & Compare_To_Zero1_out1;



  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        reset_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          reset_1 <= AND_out1;
        end
      end
    end



  Hold_Signal u_Hold_Signal (.clk(clk),
                             .reset(reset),
                             .enb(enb),
                             .triggerStart(ctrlIn_vEnd_1),
                             .triggerEnd(reset_1),
                             .Signal(Hold_Signal_out1)
                             );

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        reset_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          reset_2 <= Hold_Signal_out1;
        end
      end
    end



  assign reset_3 = (reset_2 == 1'b0 ? AccEn :
              reset_2);



  assign Compare_To_Zero_out1 = newLabel != 10'b0000000000;



  assign one1_out1 = 1'b1;



  assign mergeAccEn = (AccEn_1 == 1'b0 ? Compare_To_Zero_out1 :
              one1_out1);



  assign preblobidx = (mrgEn == 1'b0 ? newLabel :
              Merge_out1);



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_reg[0] <= 10'b0000000000;
        Delay10_reg[1] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay10_reg[0] <= Delay10_reg_next[0];
          Delay10_reg[1] <= Delay10_reg_next[1];
        end
      end
    end

  assign wraddr_1 = Delay10_reg[1];
  assign Delay10_reg_next[0] = Merge_out1;
  assign Delay10_reg_next[1] = Delay10_reg[0];



  assign blobacc_5 = (AccEn_1 == 1'b0 ? preblobidx :
              wraddr_1);



  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        pushBadIdx <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          pushBadIdx <= blobIdx;
        end
      end
    end



  assign blobacc_6 = (rdreset == 1'b0 ? blobacc_5 :
              pushBadIdx);



  assign xacc = (OR_out1 == 1'b0 ? wraddr_dtc :
              xAdd);



  x_accum u_x_accum (.clk(clk),
                     .reset(reset),
                     .enb(enb),
                     .Inc(xacc),  // ufix24
                     .Rst(reset_3),
                     .En(mergeAccEn),
                     .blobIdx(blobacc_6),  // ufix10
                     .Cnt(xAdd)  // ufix24
                     );

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_reg[0] <= 8'b00000000;
        Delay6_reg[1] <= 8'b00000000;
        Delay6_reg[2] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay6_reg[0] <= Delay6_reg_next[0];
          Delay6_reg[1] <= Delay6_reg_next[1];
          Delay6_reg[2] <= Delay6_reg_next[2];
        end
      end
    end

  assign wraddr_2 = Delay6_reg[2];
  assign Delay6_reg_next[0] = Ypos;
  assign Delay6_reg_next[1] = Delay6_reg[0];
  assign Delay6_reg_next[2] = Delay6_reg[1];



  assign wraddr_dtc_1 = {16'b0, wraddr_2};



  assign yacc = (OR_out1 == 1'b0 ? wraddr_dtc_1 :
              yAdd);



  y_accum u_y_accum (.clk(clk),
                     .reset(reset),
                     .enb(enb),
                     .Inc(yacc),  // ufix24
                     .Rst(reset_3),
                     .En(mergeAccEn),
                     .blobIdx(blobacc_6),  // ufix10
                     .Cnt(yAdd)  // ufix24
                     );

  assign one_out1 = 17'b00000000000000001;



  assign nptacc = (OR_out1 == 1'b0 ? one_out1 :
              area);



  npts_accum u_npts_accum (.clk(clk),
                           .reset(reset),
                           .enb(enb),
                           .Inc(nptacc),  // ufix17
                           .Rst(reset_3),
                           .En(mergeAccEn),
                           .blobIdx(blobacc_6),  // ufix10
                           .Cnt(area)  // ufix17
                           );

  accum_to_pos u_accum_to_pos (.clk(clk),
                               .reset(reset),
                               .enb(enb),
                               .x_accum(xAdd),  // ufix24
                               .y_accum(yAdd),  // ufix24
                               .npoints(area),  // ufix17
                               .x_o(xpos_1),  // ufix56_En30
                               .y_o(ypos_1)  // ufix56_En30
                               );

  assign x_o = xpos_1;

  assign y_o = ypos_1;

  assign y = {wraddr, wraddr_2, wraddr, wraddr_2};



  assign bboxacc = (OR_out1 == 1'b0 ? y :
              area_1);



  bbox_store u_bbox_store (.clk(clk),
                           .reset(reset),
                           .enb(enb),
                           .bbox_i(bboxacc),  // ufix34
                           .Rst(reset_2),
                           .En(mergeAccEn),
                           .blobIdx(blobacc_6),  // ufix10
                           .BBox(area_1)  // ufix34
                           );

  SingleEdgeDetectorL2H1 u_SingleEdgeDetectorL2H1 (.clk(clk),
                                                   .reset(reset),
                                                   .enb(enb),
                                                   .sync(AND_out1),
                                                   .Out1(SingleEdgeDetectorL2H1_out1)
                                                   );

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_reg[0] <= 1'b0;
        Delay7_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_reg[0] <= Delay7_reg_next[0];
          Delay7_reg[1] <= Delay7_reg_next[1];
        end
      end
    end

  assign last_o_1 = Delay7_reg[1];
  assign Delay7_reg_next[0] = SingleEdgeDetectorL2H1_out1;
  assign Delay7_reg_next[1] = Delay7_reg[0];



  assign mergedInput = {area, area_1, last_o_1, valid_1, numFnd};



  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 69'h000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 29
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 5'b11101) begin
            mergedDelay_waddr <= 5'b00000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 5'b00001;
          end
        end
      end
    end



  assign mergedDelay_wrenb = 1'b1;



  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 29
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 5'b00001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 5'b11101) begin
            mergedDelay_raddr <= 5'b00000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 5'b00001;
          end
        end
      end
    end



  SimpleDualPortRAM_generic_block1 #(.AddrWidth(5),
                                     .DataWidth(69)
                                     )
                                   u_ShiftRegisterRAM (.clk(clk),
                                                       .enb(enb),
                                                       .wr_din(mergedDelay_regin),
                                                       .wr_addr(mergedDelay_waddr),
                                                       .wr_en(mergedDelay_wrenb),  // ufix1
                                                       .rd_addr(mergedDelay_raddr),
                                                       .rd_dout(mergedDelay_regout)
                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 69'h000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end



  assign slicedInput = mergedOutput[68:52];



  assign area_o = slicedInput;

  assign slicedInput_1 = mergedOutput[16];



  assign Integer_Delay3_out1 = (slicedInput_1 != 1'b0 ? 1'b1 :
              1'b0);



  assign valid_o = Integer_Delay3_out1;

  assign slicedInput_2 = mergedOutput[17];



  assign Integer_Delay2_out1 = (slicedInput_2 != 1'b0 ? 1'b1 :
              1'b0);



  assign last_o = Integer_Delay2_out1;

  assign slicedInput_3 = mergedOutput[15:0];



  assign Integer_Delay5_out1 = slicedInput_3;



  assign num_o = Integer_Delay5_out1;

  assign slicedInput_4 = mergedOutput[51:18];



  assign bbox_o = slicedInput_4;

endmodule  // cca

