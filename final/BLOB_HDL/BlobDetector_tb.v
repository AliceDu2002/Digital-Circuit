// -------------------------------------------------------------
// 
// File Name: C:\Users\team06\Documents\MATLAB\Examples\R2022b\visionhdl\BlobAnalysisExample\verilog_hdl\BlobAnalysisHDL\BlobDetector_tb.v
// Created: 2022-12-23 11:40:06
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1.27961e-07
// Target subsystem base rate: 1.27961e-07
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1.27961e-07
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// pixelOutR                     ce_out        1.27961e-07
// pixelOutG                     ce_out        1.27961e-07
// pixelOutB                     ce_out        1.27961e-07
// ctrlOut_hStart                ce_out        1.27961e-07
// ctrlOut_hEnd                  ce_out        1.27961e-07
// ctrlOut_vStart                ce_out        1.27961e-07
// ctrlOut_vEnd                  ce_out        1.27961e-07
// ctrlOut_valid                 ce_out        1.27961e-07
// x_o                           ce_out        1.27961e-07
// y_o                           ce_out        1.27961e-07
// area_o                        ce_out        1.27961e-07
// bbox_x1_o                     ce_out        1.27961e-07
// bbox_y1_o                     ce_out        1.27961e-07
// bbox_x2_o                     ce_out        1.27961e-07
// bbox_y2_o                     ce_out        1.27961e-07
// fbidx_o                       ce_out        1.27961e-07
// num_o                         ce_out        1.27961e-07
// data_ready_o                  ce_out        1.27961e-07
// totalNum_o                    ce_out        1.27961e-07
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: BlobDetector_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module BlobDetector_tb;



  reg  clk;
  reg  reset;
  wire clk_enable;
  wire [7:0] rawData_GradThresh;  // uint8
  wire [31:0] rawData_AreaThresh;  // uint32
  wire rawData_CloseOp;
  wire [7:0] rawData_VideoMode;  // uint8
  wire totalNum_o_done;  // ufix1
  wire rdEnb;
  wire totalNum_o_done_enb;  // ufix1
  reg [16:0] pixelOutR_addr;  // ufix17
  wire totalNum_o_lastAddr;  // ufix1
  wire resetn;
  reg  check19_done;  // ufix1
  wire data_ready_o_done;  // ufix1
  wire data_ready_o_done_enb;  // ufix1
  wire data_ready_o_lastAddr;  // ufix1
  reg  check18_done;  // ufix1
  wire num_o_done;  // ufix1
  wire num_o_done_enb;  // ufix1
  wire num_o_lastAddr;  // ufix1
  reg  check17_done;  // ufix1
  wire fbidx_o_done;  // ufix1
  wire fbidx_o_done_enb;  // ufix1
  wire fbidx_o_lastAddr;  // ufix1
  reg  check16_done;  // ufix1
  wire bbox_y2_o_done;  // ufix1
  wire bbox_y2_o_done_enb;  // ufix1
  wire bbox_y2_o_lastAddr;  // ufix1
  reg  check15_done;  // ufix1
  wire bbox_x2_o_done;  // ufix1
  wire bbox_x2_o_done_enb;  // ufix1
  wire bbox_x2_o_lastAddr;  // ufix1
  reg  check14_done;  // ufix1
  wire bbox_y1_o_done;  // ufix1
  wire bbox_y1_o_done_enb;  // ufix1
  wire bbox_y1_o_lastAddr;  // ufix1
  reg  check13_done;  // ufix1
  wire bbox_x1_o_done;  // ufix1
  wire bbox_x1_o_done_enb;  // ufix1
  wire bbox_x1_o_lastAddr;  // ufix1
  reg  check12_done;  // ufix1
  wire area_o_done;  // ufix1
  wire area_o_done_enb;  // ufix1
  wire area_o_lastAddr;  // ufix1
  reg  check11_done;  // ufix1
  wire y_o_done;  // ufix1
  wire y_o_done_enb;  // ufix1
  wire y_o_lastAddr;  // ufix1
  reg  check10_done;  // ufix1
  wire x_o_done;  // ufix1
  wire x_o_done_enb;  // ufix1
  wire x_o_lastAddr;  // ufix1
  reg  check9_done;  // ufix1
  wire ctrlOut_valid_done;  // ufix1
  wire ctrlOut_valid_done_enb;  // ufix1
  wire ctrlOut_valid_lastAddr;  // ufix1
  reg  check8_done;  // ufix1
  wire ctrlOut_vEnd_done;  // ufix1
  wire ctrlOut_vEnd_done_enb;  // ufix1
  wire ctrlOut_vEnd_lastAddr;  // ufix1
  reg  check7_done;  // ufix1
  wire ctrlOut_vStart_done;  // ufix1
  wire ctrlOut_vStart_done_enb;  // ufix1
  wire ctrlOut_vStart_lastAddr;  // ufix1
  reg  check6_done;  // ufix1
  wire ctrlOut_hEnd_done;  // ufix1
  wire ctrlOut_hEnd_done_enb;  // ufix1
  wire ctrlOut_hEnd_lastAddr;  // ufix1
  reg  check5_done;  // ufix1
  wire ctrlOut_hStart_done;  // ufix1
  wire ctrlOut_hStart_done_enb;  // ufix1
  wire ctrlOut_hStart_lastAddr;  // ufix1
  reg  check4_done;  // ufix1
  wire pixelOutB_done;  // ufix1
  wire pixelOutB_done_enb;  // ufix1
  wire pixelOutB_lastAddr;  // ufix1
  reg  check3_done;  // ufix1
  wire pixelOutG_done;  // ufix1
  wire pixelOutG_done_enb;  // ufix1
  wire pixelOutG_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire pixelOutR_done;  // ufix1
  wire pixelOutR_done_enb;  // ufix1
  wire pixelOutR_active;  // ufix1
  reg [16:0] Selector_out1_addr;  // ufix17
  wire [16:0] Delay2_out1_addr_delay_1;  // ufix17
  reg  tb_enb_delay;
  reg signed [31:0] fp_blobIndex;  // sfix32
  reg [9:0] rawData_blobIndex;  // ufix10
  reg signed [31:0] status_blobIndex;  // sfix32
  reg [9:0] holdData_blobIndex;  // ufix10
  reg [9:0] blobIndex_offset;  // ufix10
  wire [9:0] blobIndex;  // ufix10
  reg [7:0] holdData_VideoMode;  // uint8
  reg [7:0] VideoMode_offset;  // uint8
  wire [7:0] VideoMode_1;  // uint8
  reg  holdData_CloseOp;
  reg  CloseOp_offset;
  wire CloseOp_1;
  reg [31:0] holdData_AreaThresh;  // uint32
  reg [31:0] AreaThresh_offset;  // uint32
  wire [31:0] AreaThresh_1;  // uint32
  reg [7:0] holdData_GradThresh;  // uint8
  reg [7:0] GradThresh_offset;  // uint8
  wire [7:0] GradThresh_1;  // uint8
  wire [16:0] Frame_To_Pixels_out2_4_bus_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlIn_valid;  // sfix32
  reg  rawData_ctrlIn_valid;
  reg signed [31:0] status_ctrlIn_valid;  // sfix32
  reg  holdData_ctrlIn_valid;
  reg  ctrlIn_valid_offset;
  wire ctrlIn_valid;
  wire [16:0] Frame_To_Pixels_out2_3_bus_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlIn_vEnd;  // sfix32
  reg  rawData_ctrlIn_vEnd;
  reg signed [31:0] status_ctrlIn_vEnd;  // sfix32
  reg  holdData_ctrlIn_vEnd;
  reg  ctrlIn_vEnd_offset;
  wire ctrlIn_vEnd;
  wire [16:0] Frame_To_Pixels_out2_2_bus_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlIn_vStart;  // sfix32
  reg  rawData_ctrlIn_vStart;
  reg signed [31:0] status_ctrlIn_vStart;  // sfix32
  reg  holdData_ctrlIn_vStart;
  reg  ctrlIn_vStart_offset;
  wire ctrlIn_vStart;
  wire [16:0] Frame_To_Pixels_out2_1_bus_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlIn_hEnd;  // sfix32
  reg  rawData_ctrlIn_hEnd;
  reg signed [31:0] status_ctrlIn_hEnd;  // sfix32
  reg  holdData_ctrlIn_hEnd;
  reg  ctrlIn_hEnd_offset;
  wire ctrlIn_hEnd;
  wire [16:0] Frame_To_Pixels_out2_bus_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlIn_hStart;  // sfix32
  reg  rawData_ctrlIn_hStart;
  reg signed [31:0] status_ctrlIn_hStart;  // sfix32
  reg  holdData_ctrlIn_hStart;
  reg  ctrlIn_hStart_offset;
  wire ctrlIn_hStart;
  wire [16:0] Selector2_out1_addr_delay_1;  // ufix17
  reg signed [31:0] fp_pixelInB;  // sfix32
  reg [7:0] rawData_pixelInB;  // uint8
  reg signed [31:0] status_pixelInB;  // sfix32
  reg [7:0] holdData_pixelInB;  // uint8
  reg [7:0] pixelInB_offset;  // uint8
  wire [7:0] pixelInB;  // uint8
  wire [16:0] Selector1_out1_addr_delay_1;  // ufix17
  reg signed [31:0] fp_pixelInG;  // sfix32
  reg [7:0] rawData_pixelInG;  // uint8
  reg signed [31:0] status_pixelInG;  // sfix32
  reg [7:0] holdData_pixelInG;  // uint8
  reg [7:0] pixelInG_offset;  // uint8
  wire [7:0] pixelInG;  // uint8
  wire Selector_out1_active;  // ufix1
  wire Selector_out1_enb;  // ufix1
  wire [16:0] Selector_out1_addr_delay_1;  // ufix17
  reg signed [31:0] fp_pixelInR;  // sfix32
  reg [7:0] rawData_pixelInR;  // uint8
  reg signed [31:0] status_pixelInR;  // sfix32
  reg [7:0] holdData_pixelInR;  // uint8
  reg [7:0] pixelInR_offset;  // uint8
  wire [7:0] pixelInR;  // uint8
  reg  snkDone;
  wire snkDonen;
  wire tb_enb;
  wire ce_out;
  wire [7:0] pixelOutR;  // uint8
  wire [7:0] pixelOutG;  // uint8
  wire [7:0] pixelOutB;  // uint8
  wire ctrlOut_hStart;
  wire ctrlOut_hEnd;
  wire ctrlOut_vStart;
  wire ctrlOut_vEnd;
  wire ctrlOut_valid;
  wire [15:0] x_o;  // uint16
  wire [15:0] y_o;  // uint16
  wire [16:0] area_o;  // ufix17
  wire [8:0] bbox_x1_o;  // ufix9
  wire [7:0] bbox_y1_o;  // uint8
  wire [8:0] bbox_x2_o;  // ufix9
  wire [7:0] bbox_y2_o;  // uint8
  wire [9:0] fbidx_o;  // ufix10
  wire [15:0] num_o;  // uint16
  wire data_ready_o;
  wire [15:0] totalNum_o;  // uint16
  wire pixelOutR_enb;  // ufix1
  wire pixelOutR_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  reg [3:0] pixelOutR_chkcnt;  // ufix4
  wire pixelOutR_ignCntDone;  // ufix1
  wire pixelOutR_needToCount;  // ufix1
  wire pixelOutR_chkenb;  // ufix1
  wire pixelOutR_chkdata;  // ufix1
  wire [16:0] pixelOutR_addr_delay_1;  // ufix17
  reg signed [31:0] fp_pixelOutR_expected;  // sfix32
  reg [7:0] pixelOutR_expected;  // uint8
  reg signed [31:0] status_pixelOutR_expected;  // sfix32
  wire [7:0] pixelOutR_ref;  // uint8
  reg  pixelOutR_testFailure;  // ufix1
  reg [3:0] pixelOutG_chkcnt;  // ufix4
  wire pixelOutG_ignCntDone;  // ufix1
  wire pixelOutG_needToCount;  // ufix1
  wire pixelOutG_chkenb;  // ufix1
  wire pixelOutG_chkdata;  // ufix1
  wire [16:0] pixelOutG_addr_delay_1;  // ufix17
  reg signed [31:0] fp_pixelOutG_expected;  // sfix32
  reg [7:0] pixelOutG_expected;  // uint8
  reg signed [31:0] status_pixelOutG_expected;  // sfix32
  wire [7:0] pixelOutG_ref;  // uint8
  reg  pixelOutG_testFailure;  // ufix1
  reg [3:0] pixelOutB_chkcnt;  // ufix4
  wire pixelOutB_ignCntDone;  // ufix1
  wire pixelOutB_needToCount;  // ufix1
  wire pixelOutB_chkenb;  // ufix1
  wire pixelOutB_chkdata;  // ufix1
  wire [7:0] pixelOutB_expected_1;  // uint8
  wire [7:0] pixelOutB_ref;  // uint8
  reg  pixelOutB_testFailure;  // ufix1
  reg [3:0] ctrlOut_hStart_chkcnt;  // ufix4
  wire ctrlOut_hStart_ignCntDone;  // ufix1
  wire ctrlOut_hStart_needToCount;  // ufix1
  wire ctrlOut_hStart_chkenb;  // ufix1
  wire ctrlOut_hStart_chkdata;  // ufix1
  wire [16:0] ctrlOut_hStart_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlOut_hStart_expected;  // sfix32
  reg  ctrlOut_hStart_expected;
  reg signed [31:0] status_ctrlOut_hStart_expected;  // sfix32
  wire ctrlOut_hStart_ref;
  reg  ctrlOut_hStart_testFailure;  // ufix1
  reg [3:0] ctrlOut_hEnd_chkcnt;  // ufix4
  wire ctrlOut_hEnd_ignCntDone;  // ufix1
  wire ctrlOut_hEnd_needToCount;  // ufix1
  wire ctrlOut_hEnd_chkenb;  // ufix1
  wire ctrlOut_hEnd_chkdata;  // ufix1
  wire [16:0] ctrlOut_hEnd_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlOut_hEnd_expected;  // sfix32
  reg  ctrlOut_hEnd_expected;
  reg signed [31:0] status_ctrlOut_hEnd_expected;  // sfix32
  wire ctrlOut_hEnd_ref;
  reg  ctrlOut_hEnd_testFailure;  // ufix1
  reg [3:0] ctrlOut_vStart_chkcnt;  // ufix4
  wire ctrlOut_vStart_ignCntDone;  // ufix1
  wire ctrlOut_vStart_needToCount;  // ufix1
  wire ctrlOut_vStart_chkenb;  // ufix1
  wire ctrlOut_vStart_chkdata;  // ufix1
  wire [16:0] ctrlOut_vStart_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlOut_vStart_expected;  // sfix32
  reg  ctrlOut_vStart_expected;
  reg signed [31:0] status_ctrlOut_vStart_expected;  // sfix32
  wire ctrlOut_vStart_ref;
  reg  ctrlOut_vStart_testFailure;  // ufix1
  reg [3:0] ctrlOut_vEnd_chkcnt;  // ufix4
  wire ctrlOut_vEnd_ignCntDone;  // ufix1
  wire ctrlOut_vEnd_needToCount;  // ufix1
  wire ctrlOut_vEnd_chkenb;  // ufix1
  wire ctrlOut_vEnd_chkdata;  // ufix1
  wire [16:0] ctrlOut_vEnd_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlOut_vEnd_expected;  // sfix32
  reg  ctrlOut_vEnd_expected;
  reg signed [31:0] status_ctrlOut_vEnd_expected;  // sfix32
  wire ctrlOut_vEnd_ref;
  reg  ctrlOut_vEnd_testFailure;  // ufix1
  reg [3:0] ctrlOut_valid_chkcnt;  // ufix4
  wire ctrlOut_valid_ignCntDone;  // ufix1
  wire ctrlOut_valid_needToCount;  // ufix1
  wire ctrlOut_valid_chkenb;  // ufix1
  wire ctrlOut_valid_chkdata;  // ufix1
  wire [16:0] ctrlOut_valid_addr_delay_1;  // ufix17
  reg signed [31:0] fp_ctrlOut_valid_expected;  // sfix32
  reg  ctrlOut_valid_expected;
  reg signed [31:0] status_ctrlOut_valid_expected;  // sfix32
  wire ctrlOut_valid_ref;
  reg  ctrlOut_valid_testFailure;  // ufix1
  reg [3:0] x_o_chkcnt;  // ufix4
  wire x_o_ignCntDone;  // ufix1
  wire x_o_needToCount;  // ufix1
  wire x_o_chkenb;  // ufix1
  wire x_o_chkdata;  // ufix1
  wire [16:0] x_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_x_o_expected;  // sfix32
  reg [15:0] x_o_expected;  // uint16
  reg signed [31:0] status_x_o_expected;  // sfix32
  wire [15:0] x_o_ref;  // uint16
  reg  x_o_testFailure;  // ufix1
  reg [3:0] y_o_chkcnt;  // ufix4
  wire y_o_ignCntDone;  // ufix1
  wire y_o_needToCount;  // ufix1
  wire y_o_chkenb;  // ufix1
  wire y_o_chkdata;  // ufix1
  wire [16:0] y_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_y_o_expected;  // sfix32
  reg [15:0] y_o_expected;  // uint16
  reg signed [31:0] status_y_o_expected;  // sfix32
  wire [15:0] y_o_ref;  // uint16
  reg  y_o_testFailure;  // ufix1
  reg [3:0] area_o_chkcnt;  // ufix4
  wire area_o_ignCntDone;  // ufix1
  wire area_o_needToCount;  // ufix1
  wire area_o_chkenb;  // ufix1
  wire area_o_chkdata;  // ufix1
  wire [16:0] area_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_area_o_expected;  // sfix32
  reg [16:0] area_o_expected;  // ufix17
  reg signed [31:0] status_area_o_expected;  // sfix32
  wire [16:0] area_o_ref;  // ufix17
  reg  area_o_testFailure;  // ufix1
  reg [3:0] bbox_x1_o_chkcnt;  // ufix4
  wire bbox_x1_o_ignCntDone;  // ufix1
  wire bbox_x1_o_needToCount;  // ufix1
  wire bbox_x1_o_chkenb;  // ufix1
  wire bbox_x1_o_chkdata;  // ufix1
  wire [16:0] bbox_x1_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_bbox_x1_o_expected;  // sfix32
  reg [8:0] bbox_x1_o_expected;  // ufix9
  reg signed [31:0] status_bbox_x1_o_expected;  // sfix32
  wire [8:0] bbox_x1_o_ref;  // ufix9
  reg  bbox_x1_o_testFailure;  // ufix1
  reg [3:0] bbox_y1_o_chkcnt;  // ufix4
  wire bbox_y1_o_ignCntDone;  // ufix1
  wire bbox_y1_o_needToCount;  // ufix1
  wire bbox_y1_o_chkenb;  // ufix1
  wire bbox_y1_o_chkdata;  // ufix1
  wire [16:0] bbox_y1_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_bbox_y1_o_expected;  // sfix32
  reg [7:0] bbox_y1_o_expected;  // uint8
  reg signed [31:0] status_bbox_y1_o_expected;  // sfix32
  wire [7:0] bbox_y1_o_ref;  // uint8
  reg  bbox_y1_o_testFailure;  // ufix1
  reg [3:0] bbox_x2_o_chkcnt;  // ufix4
  wire bbox_x2_o_ignCntDone;  // ufix1
  wire bbox_x2_o_needToCount;  // ufix1
  wire bbox_x2_o_chkenb;  // ufix1
  wire bbox_x2_o_chkdata;  // ufix1
  wire [16:0] bbox_x2_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_bbox_x2_o_expected;  // sfix32
  reg [8:0] bbox_x2_o_expected;  // ufix9
  reg signed [31:0] status_bbox_x2_o_expected;  // sfix32
  wire [8:0] bbox_x2_o_ref;  // ufix9
  reg  bbox_x2_o_testFailure;  // ufix1
  reg [3:0] bbox_y2_o_chkcnt;  // ufix4
  wire bbox_y2_o_ignCntDone;  // ufix1
  wire bbox_y2_o_needToCount;  // ufix1
  wire bbox_y2_o_chkenb;  // ufix1
  wire bbox_y2_o_chkdata;  // ufix1
  wire [16:0] bbox_y2_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_bbox_y2_o_expected;  // sfix32
  reg [7:0] bbox_y2_o_expected;  // uint8
  reg signed [31:0] status_bbox_y2_o_expected;  // sfix32
  wire [7:0] bbox_y2_o_ref;  // uint8
  reg  bbox_y2_o_testFailure;  // ufix1
  reg [3:0] fbidx_o_chkcnt;  // ufix4
  wire fbidx_o_ignCntDone;  // ufix1
  wire fbidx_o_needToCount;  // ufix1
  wire fbidx_o_chkenb;  // ufix1
  wire fbidx_o_chkdata;  // ufix1
  wire [16:0] fbidx_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_fbidx_o_expected;  // sfix32
  reg [9:0] fbidx_o_expected;  // ufix10
  reg signed [31:0] status_fbidx_o_expected;  // sfix32
  wire [9:0] fbidx_o_ref;  // ufix10
  reg  fbidx_o_testFailure;  // ufix1
  reg [3:0] num_o_chkcnt;  // ufix4
  wire num_o_ignCntDone;  // ufix1
  wire num_o_needToCount;  // ufix1
  wire num_o_chkenb;  // ufix1
  wire num_o_chkdata;  // ufix1
  wire [16:0] num_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_num_o_expected;  // sfix32
  reg [15:0] num_o_expected;  // uint16
  reg signed [31:0] status_num_o_expected;  // sfix32
  wire [15:0] num_o_ref;  // uint16
  reg  num_o_testFailure;  // ufix1
  reg [3:0] data_ready_o_chkcnt;  // ufix4
  wire data_ready_o_ignCntDone;  // ufix1
  wire data_ready_o_needToCount;  // ufix1
  wire data_ready_o_chkenb;  // ufix1
  wire data_ready_o_chkdata;  // ufix1
  wire [16:0] data_ready_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_data_ready_o_expected;  // sfix32
  reg  data_ready_o_expected;
  reg signed [31:0] status_data_ready_o_expected;  // sfix32
  wire data_ready_o_ref;
  reg  data_ready_o_testFailure;  // ufix1
  reg [3:0] totalNum_o_chkcnt;  // ufix4
  wire totalNum_o_ignCntDone;  // ufix1
  wire totalNum_o_needToCount;  // ufix1
  wire totalNum_o_chkenb;  // ufix1
  wire totalNum_o_chkdata;  // ufix1
  wire [16:0] totalNum_o_addr_delay_1;  // ufix17
  reg signed [31:0] fp_totalNum_o_expected;  // sfix32
  reg [15:0] totalNum_o_expected;  // uint16
  reg signed [31:0] status_totalNum_o_expected;  // sfix32
  wire [15:0] totalNum_o_ref;  // uint16
  reg  totalNum_o_testFailure;  // ufix1
  reg  testFailure;  // ufix1

  function real absReal(input real num);
  begin
    if (num < 0)
      absReal = -num;
    else
      absReal = num;
  end
  endfunction

  function real floatHalfToReal;
  input [15:0] x;
  reg [63:0] conv;

  begin
    conv[63] = x[15]; // sign 
    if (x[14:10] == 5'b0) // exp 
      conv[62:52] = 11'b0; 
    else
      conv[62:52] = 1023 + (x[14:10] - 15);
    conv[51:42] = x[9:0]; // mantissa 
    conv[41:0] = 42'b0;
    if (((x[14:10] == 5'h1F) && (x[9:0] != 10'h0))) // check for NaN 
    begin
      conv[63] = 1'b0;
      conv[62:52] = 11'h7FF;
      conv[51:0] = 52'h0;
    end
    floatHalfToReal = $bitstoreal(conv);
  end
  endfunction

  function real floatSingleToReal;
  input [31:0] x;
  reg [63:0] conv;

  begin
    conv[63] = x[31]; // sign 
    if (x[30:23] == 8'b0) // exp 
      conv[62:52] = 11'b0; 
    else
      conv[62:52] = 1023 + (x[30:23] - 127);
    conv[51:29] = x[22:0]; // mantissa 
    conv[28:0] = 29'b0;
    if (((x[30:23] == 8'hFF) && (x[22:0] != 23'h0))) // check for NaN 
    begin
      conv[63] = 1'b0;
      conv[62:52] = 11'h7FF;
      conv[51:0] = 52'h0;
    end
    floatSingleToReal = $bitstoreal(conv);
  end
  endfunction

  function real floatDoubleToReal;
  input [63:0] x;
  reg [63:0] conv;

  begin
    conv[63:0] = x[63:0]; 
    if (((x[62:52] == 11'h7FF) && (x[51:0] != 52'h0))) // check for NaN 
    begin
      conv[63] = 1'b0;
      conv[62:52] = 11'h7FF;
      conv[51:0] = 52'h0;
    end
    floatDoubleToReal = $bitstoreal(conv);
  end
  endfunction

  function isFloatEpsEqual(input real a, input real b, input real eps);
  real absdiff;

  begin
    absdiff = absReal(a - b);
    if (absdiff < eps) // absolute error check 
      isFloatEpsEqual = 1;
    else if (a == b) // check infinities 
      isFloatEpsEqual = 1; 
    else if (a*b == 0.0) // either is zero 
      isFloatEpsEqual = (absdiff < eps);
    else if (absReal(a) < absReal(b)) // relative error check
      isFloatEpsEqual = absdiff/absReal(b) < eps;
    else
      isFloatEpsEqual = absdiff/absReal(a) < eps;
  end
  endfunction
  function isFloatHalfEpsEqual;
  input [15:0] x;
  input [15:0] y;
  input real eps;
  real a, b;
  real absdiff;

  begin
    a = floatHalfToReal(x);
    b = floatHalfToReal(y);
    isFloatHalfEpsEqual = isFloatEpsEqual(a, b, eps);
  end
  endfunction
  function isFloatSingleEpsEqual;
  input [31:0] x;
  input [31:0] y;
  input real eps;
  real a, b;
  real absdiff;

  begin
    a = floatSingleToReal(x);
    b = floatSingleToReal(y);
    isFloatSingleEpsEqual = isFloatEpsEqual(a, b, eps);
  end
  endfunction
  function isFloatDoubleEpsEqual;
  input [63:0] x;
  input [63:0] y;
  input real eps;
  real a, b;
  real absdiff;

  begin
    a = floatDoubleToReal(x);
    b = floatDoubleToReal(y);
    isFloatDoubleEpsEqual = isFloatEpsEqual(a, b, eps);
  end
  endfunction

  // Data source for GradThresh
  assign rawData_GradThresh = 8'b10000111;



  // Data source for AreaThresh
  assign rawData_AreaThresh = 32'b00000000000000000000000000000001;



  // Data source for CloseOp
  assign rawData_CloseOp = 1'b1;



  // Data source for VideoMode
  assign rawData_VideoMode = 8'b00000001;



  assign totalNum_o_done_enb = totalNum_o_done & rdEnb;



  assign totalNum_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign totalNum_o_done = totalNum_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_19
      if (reset) begin
        check19_done <= 0;
      end
      else begin
        if (totalNum_o_done_enb) begin
          check19_done <= totalNum_o_done;
        end
      end
    end

  assign data_ready_o_done_enb = data_ready_o_done & rdEnb;



  assign data_ready_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign data_ready_o_done = data_ready_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_18
      if (reset) begin
        check18_done <= 0;
      end
      else begin
        if (data_ready_o_done_enb) begin
          check18_done <= data_ready_o_done;
        end
      end
    end

  assign num_o_done_enb = num_o_done & rdEnb;



  assign num_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign num_o_done = num_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_17
      if (reset) begin
        check17_done <= 0;
      end
      else begin
        if (num_o_done_enb) begin
          check17_done <= num_o_done;
        end
      end
    end

  assign fbidx_o_done_enb = fbidx_o_done & rdEnb;



  assign fbidx_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign fbidx_o_done = fbidx_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_16
      if (reset) begin
        check16_done <= 0;
      end
      else begin
        if (fbidx_o_done_enb) begin
          check16_done <= fbidx_o_done;
        end
      end
    end

  assign bbox_y2_o_done_enb = bbox_y2_o_done & rdEnb;



  assign bbox_y2_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign bbox_y2_o_done = bbox_y2_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_15
      if (reset) begin
        check15_done <= 0;
      end
      else begin
        if (bbox_y2_o_done_enb) begin
          check15_done <= bbox_y2_o_done;
        end
      end
    end

  assign bbox_x2_o_done_enb = bbox_x2_o_done & rdEnb;



  assign bbox_x2_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign bbox_x2_o_done = bbox_x2_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_14
      if (reset) begin
        check14_done <= 0;
      end
      else begin
        if (bbox_x2_o_done_enb) begin
          check14_done <= bbox_x2_o_done;
        end
      end
    end

  assign bbox_y1_o_done_enb = bbox_y1_o_done & rdEnb;



  assign bbox_y1_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign bbox_y1_o_done = bbox_y1_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_13
      if (reset) begin
        check13_done <= 0;
      end
      else begin
        if (bbox_y1_o_done_enb) begin
          check13_done <= bbox_y1_o_done;
        end
      end
    end

  assign bbox_x1_o_done_enb = bbox_x1_o_done & rdEnb;



  assign bbox_x1_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign bbox_x1_o_done = bbox_x1_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_12
      if (reset) begin
        check12_done <= 0;
      end
      else begin
        if (bbox_x1_o_done_enb) begin
          check12_done <= bbox_x1_o_done;
        end
      end
    end

  assign area_o_done_enb = area_o_done & rdEnb;



  assign area_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign area_o_done = area_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_11
      if (reset) begin
        check11_done <= 0;
      end
      else begin
        if (area_o_done_enb) begin
          check11_done <= area_o_done;
        end
      end
    end

  assign y_o_done_enb = y_o_done & rdEnb;



  assign y_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign y_o_done = y_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_10
      if (reset) begin
        check10_done <= 0;
      end
      else begin
        if (y_o_done_enb) begin
          check10_done <= y_o_done;
        end
      end
    end

  assign x_o_done_enb = x_o_done & rdEnb;



  assign x_o_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign x_o_done = x_o_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_9
      if (reset) begin
        check9_done <= 0;
      end
      else begin
        if (x_o_done_enb) begin
          check9_done <= x_o_done;
        end
      end
    end

  assign ctrlOut_valid_done_enb = ctrlOut_valid_done & rdEnb;



  assign ctrlOut_valid_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign ctrlOut_valid_done = ctrlOut_valid_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_8
      if (reset) begin
        check8_done <= 0;
      end
      else begin
        if (ctrlOut_valid_done_enb) begin
          check8_done <= ctrlOut_valid_done;
        end
      end
    end

  assign ctrlOut_vEnd_done_enb = ctrlOut_vEnd_done & rdEnb;



  assign ctrlOut_vEnd_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign ctrlOut_vEnd_done = ctrlOut_vEnd_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_7
      if (reset) begin
        check7_done <= 0;
      end
      else begin
        if (ctrlOut_vEnd_done_enb) begin
          check7_done <= ctrlOut_vEnd_done;
        end
      end
    end

  assign ctrlOut_vStart_done_enb = ctrlOut_vStart_done & rdEnb;



  assign ctrlOut_vStart_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign ctrlOut_vStart_done = ctrlOut_vStart_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_6
      if (reset) begin
        check6_done <= 0;
      end
      else begin
        if (ctrlOut_vStart_done_enb) begin
          check6_done <= ctrlOut_vStart_done;
        end
      end
    end

  assign ctrlOut_hEnd_done_enb = ctrlOut_hEnd_done & rdEnb;



  assign ctrlOut_hEnd_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign ctrlOut_hEnd_done = ctrlOut_hEnd_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_5
      if (reset) begin
        check5_done <= 0;
      end
      else begin
        if (ctrlOut_hEnd_done_enb) begin
          check5_done <= ctrlOut_hEnd_done;
        end
      end
    end

  assign ctrlOut_hStart_done_enb = ctrlOut_hStart_done & rdEnb;



  assign ctrlOut_hStart_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign ctrlOut_hStart_done = ctrlOut_hStart_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_4
      if (reset) begin
        check4_done <= 0;
      end
      else begin
        if (ctrlOut_hStart_done_enb) begin
          check4_done <= ctrlOut_hStart_done;
        end
      end
    end

  assign pixelOutB_done_enb = pixelOutB_done & rdEnb;



  assign pixelOutB_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign pixelOutB_done = pixelOutB_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_3
      if (reset) begin
        check3_done <= 0;
      end
      else begin
        if (pixelOutB_done_enb) begin
          check3_done <= pixelOutB_done;
        end
      end
    end

  assign pixelOutG_done_enb = pixelOutG_done & rdEnb;



  assign pixelOutG_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign pixelOutG_done = pixelOutG_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_2
      if (reset) begin
        check2_done <= 0;
      end
      else begin
        if (pixelOutG_done_enb) begin
          check2_done <= pixelOutG_done;
        end
      end
    end

  assign pixelOutR_done_enb = pixelOutR_done & rdEnb;



  assign pixelOutR_active = pixelOutR_addr != 17'b11111110011001000;



  assign #1 Delay2_out1_addr_delay_1 = Selector_out1_addr;

  // Data source for blobIndex
  initial
    begin : blobIndex_fileread
      fp_blobIndex = $fopen("blobIndex.dat", "r");
      status_blobIndex = $rewind(fp_blobIndex);
    end

  always @(Delay2_out1_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_blobIndex <= 10'bx;
      end
      else if (rdEnb == 1) begin
        status_blobIndex = $fscanf(fp_blobIndex, "%h", rawData_blobIndex);
      end
    end

  // holdData reg for Delay2_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Delay2_out1
      if (reset) begin
        holdData_blobIndex <= 10'bx;
      end
      else begin
        holdData_blobIndex <= rawData_blobIndex;
      end
    end

  always @(rawData_blobIndex or rdEnb)
    begin : stimuli_Delay2_out1_1
      if (rdEnb == 1'b0) begin
        blobIndex_offset <= holdData_blobIndex;
      end
      else begin
        blobIndex_offset <= rawData_blobIndex;
      end
    end

  assign #2 blobIndex = blobIndex_offset;

  // holdData reg for VideoMode_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_VideoMode_out1
      if (reset) begin
        holdData_VideoMode <= 8'bx;
      end
      else begin
        holdData_VideoMode <= rawData_VideoMode;
      end
    end

  always @(rawData_VideoMode or rdEnb)
    begin : stimuli_VideoMode_out1_1
      if (rdEnb == 1'b0) begin
        VideoMode_offset <= holdData_VideoMode;
      end
      else begin
        VideoMode_offset <= rawData_VideoMode;
      end
    end

  assign #2 VideoMode_1 = VideoMode_offset;

  // holdData reg for PerformClosing_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_PerformClosing_out1
      if (reset) begin
        holdData_CloseOp <= 1'bx;
      end
      else begin
        holdData_CloseOp <= rawData_CloseOp;
      end
    end

  always @(rawData_CloseOp or rdEnb)
    begin : stimuli_PerformClosing_out1_1
      if (rdEnb == 1'b0) begin
        CloseOp_offset <= holdData_CloseOp;
      end
      else begin
        CloseOp_offset <= rawData_CloseOp;
      end
    end

  assign #2 CloseOp_1 = CloseOp_offset;

  // holdData reg for AreaThresh_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_AreaThresh_out1
      if (reset) begin
        holdData_AreaThresh <= 32'bx;
      end
      else begin
        holdData_AreaThresh <= rawData_AreaThresh;
      end
    end

  always @(rawData_AreaThresh or rdEnb)
    begin : stimuli_AreaThresh_out1_1
      if (rdEnb == 1'b0) begin
        AreaThresh_offset <= holdData_AreaThresh;
      end
      else begin
        AreaThresh_offset <= rawData_AreaThresh;
      end
    end

  assign #2 AreaThresh_1 = AreaThresh_offset;

  // holdData reg for GradientThreshold_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_GradientThreshold_out1
      if (reset) begin
        holdData_GradThresh <= 8'bx;
      end
      else begin
        holdData_GradThresh <= rawData_GradThresh;
      end
    end

  always @(rawData_GradThresh or rdEnb)
    begin : stimuli_GradientThreshold_out1_1
      if (rdEnb == 1'b0) begin
        GradThresh_offset <= holdData_GradThresh;
      end
      else begin
        GradThresh_offset <= rawData_GradThresh;
      end
    end

  assign #2 GradThresh_1 = GradThresh_offset;

  assign #1 Frame_To_Pixels_out2_4_bus_addr_delay_1 = Selector_out1_addr;

  // Data source for ctrlIn_valid
  initial
    begin : ctrlIn_valid_fileread
      fp_ctrlIn_valid = $fopen("ctrlIn_valid.dat", "r");
      status_ctrlIn_valid = $rewind(fp_ctrlIn_valid);
    end

  always @(Frame_To_Pixels_out2_4_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_valid <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_valid = $fscanf(fp_ctrlIn_valid, "%h", rawData_ctrlIn_valid);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_4_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_4_bus
      if (reset) begin
        holdData_ctrlIn_valid <= 1'bx;
      end
      else begin
        holdData_ctrlIn_valid <= rawData_ctrlIn_valid;
      end
    end

  always @(rawData_ctrlIn_valid or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_4_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_valid_offset <= holdData_ctrlIn_valid;
      end
      else begin
        ctrlIn_valid_offset <= rawData_ctrlIn_valid;
      end
    end

  assign #2 ctrlIn_valid = ctrlIn_valid_offset;

  assign #1 Frame_To_Pixels_out2_3_bus_addr_delay_1 = Selector_out1_addr;

  // Data source for ctrlIn_vEnd
  initial
    begin : ctrlIn_vEnd_fileread
      fp_ctrlIn_vEnd = $fopen("ctrlIn_vEnd.dat", "r");
      status_ctrlIn_vEnd = $rewind(fp_ctrlIn_vEnd);
    end

  always @(Frame_To_Pixels_out2_3_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_vEnd <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_vEnd = $fscanf(fp_ctrlIn_vEnd, "%h", rawData_ctrlIn_vEnd);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_3_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_3_bus
      if (reset) begin
        holdData_ctrlIn_vEnd <= 1'bx;
      end
      else begin
        holdData_ctrlIn_vEnd <= rawData_ctrlIn_vEnd;
      end
    end

  always @(rawData_ctrlIn_vEnd or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_3_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_vEnd_offset <= holdData_ctrlIn_vEnd;
      end
      else begin
        ctrlIn_vEnd_offset <= rawData_ctrlIn_vEnd;
      end
    end

  assign #2 ctrlIn_vEnd = ctrlIn_vEnd_offset;

  assign #1 Frame_To_Pixels_out2_2_bus_addr_delay_1 = Selector_out1_addr;

  // Data source for ctrlIn_vStart
  initial
    begin : ctrlIn_vStart_fileread
      fp_ctrlIn_vStart = $fopen("ctrlIn_vStart.dat", "r");
      status_ctrlIn_vStart = $rewind(fp_ctrlIn_vStart);
    end

  always @(Frame_To_Pixels_out2_2_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_vStart <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_vStart = $fscanf(fp_ctrlIn_vStart, "%h", rawData_ctrlIn_vStart);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_2_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_2_bus
      if (reset) begin
        holdData_ctrlIn_vStart <= 1'bx;
      end
      else begin
        holdData_ctrlIn_vStart <= rawData_ctrlIn_vStart;
      end
    end

  always @(rawData_ctrlIn_vStart or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_2_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_vStart_offset <= holdData_ctrlIn_vStart;
      end
      else begin
        ctrlIn_vStart_offset <= rawData_ctrlIn_vStart;
      end
    end

  assign #2 ctrlIn_vStart = ctrlIn_vStart_offset;

  assign #1 Frame_To_Pixels_out2_1_bus_addr_delay_1 = Selector_out1_addr;

  // Data source for ctrlIn_hEnd
  initial
    begin : ctrlIn_hEnd_fileread
      fp_ctrlIn_hEnd = $fopen("ctrlIn_hEnd.dat", "r");
      status_ctrlIn_hEnd = $rewind(fp_ctrlIn_hEnd);
    end

  always @(Frame_To_Pixels_out2_1_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_hEnd <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_hEnd = $fscanf(fp_ctrlIn_hEnd, "%h", rawData_ctrlIn_hEnd);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_1_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_1_bus
      if (reset) begin
        holdData_ctrlIn_hEnd <= 1'bx;
      end
      else begin
        holdData_ctrlIn_hEnd <= rawData_ctrlIn_hEnd;
      end
    end

  always @(rawData_ctrlIn_hEnd or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_1_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_hEnd_offset <= holdData_ctrlIn_hEnd;
      end
      else begin
        ctrlIn_hEnd_offset <= rawData_ctrlIn_hEnd;
      end
    end

  assign #2 ctrlIn_hEnd = ctrlIn_hEnd_offset;

  assign #1 Frame_To_Pixels_out2_bus_addr_delay_1 = Selector_out1_addr;

  // Data source for ctrlIn_hStart
  initial
    begin : ctrlIn_hStart_fileread
      fp_ctrlIn_hStart = $fopen("ctrlIn_hStart.dat", "r");
      status_ctrlIn_hStart = $rewind(fp_ctrlIn_hStart);
    end

  always @(Frame_To_Pixels_out2_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_hStart <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_hStart = $fscanf(fp_ctrlIn_hStart, "%h", rawData_ctrlIn_hStart);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_bus
      if (reset) begin
        holdData_ctrlIn_hStart <= 1'bx;
      end
      else begin
        holdData_ctrlIn_hStart <= rawData_ctrlIn_hStart;
      end
    end

  always @(rawData_ctrlIn_hStart or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_hStart_offset <= holdData_ctrlIn_hStart;
      end
      else begin
        ctrlIn_hStart_offset <= rawData_ctrlIn_hStart;
      end
    end

  assign #2 ctrlIn_hStart = ctrlIn_hStart_offset;

  assign #1 Selector2_out1_addr_delay_1 = Selector_out1_addr;

  // Data source for pixelInB
  initial
    begin : pixelInB_fileread
      fp_pixelInB = $fopen("pixelInB.dat", "r");
      status_pixelInB = $rewind(fp_pixelInB);
    end

  always @(Selector2_out1_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_pixelInB <= 8'bx;
      end
      else if (rdEnb == 1) begin
        status_pixelInB = $fscanf(fp_pixelInB, "%h", rawData_pixelInB);
      end
    end

  // holdData reg for Selector2_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Selector2_out1
      if (reset) begin
        holdData_pixelInB <= 8'bx;
      end
      else begin
        holdData_pixelInB <= rawData_pixelInB;
      end
    end

  always @(rawData_pixelInB or rdEnb)
    begin : stimuli_Selector2_out1_1
      if (rdEnb == 1'b0) begin
        pixelInB_offset <= holdData_pixelInB;
      end
      else begin
        pixelInB_offset <= rawData_pixelInB;
      end
    end

  assign #2 pixelInB = pixelInB_offset;

  assign #1 Selector1_out1_addr_delay_1 = Selector_out1_addr;

  // Data source for pixelInG
  initial
    begin : pixelInG_fileread
      fp_pixelInG = $fopen("pixelInG.dat", "r");
      status_pixelInG = $rewind(fp_pixelInG);
    end

  always @(Selector1_out1_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_pixelInG <= 8'bx;
      end
      else if (rdEnb == 1) begin
        status_pixelInG = $fscanf(fp_pixelInG, "%h", rawData_pixelInG);
      end
    end

  // holdData reg for Selector1_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Selector1_out1
      if (reset) begin
        holdData_pixelInG <= 8'bx;
      end
      else begin
        holdData_pixelInG <= rawData_pixelInG;
      end
    end

  always @(rawData_pixelInG or rdEnb)
    begin : stimuli_Selector1_out1_1
      if (rdEnb == 1'b0) begin
        pixelInG_offset <= holdData_pixelInG;
      end
      else begin
        pixelInG_offset <= rawData_pixelInG;
      end
    end

  assign #2 pixelInG = pixelInG_offset;

  assign Selector_out1_active = Selector_out1_addr != 17'b11111110011001000;



  assign Selector_out1_enb = Selector_out1_active & (rdEnb & tb_enb_delay);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 130248
  always @(posedge clk or posedge reset)
    begin : Selector_process
      if (reset == 1'b1) begin
        Selector_out1_addr <= 17'b00000000000000000;
      end
      else begin
        if (Selector_out1_enb) begin
          if (Selector_out1_addr >= 17'b11111110011001000) begin
            Selector_out1_addr <= 17'b00000000000000000;
          end
          else begin
            Selector_out1_addr <= Selector_out1_addr + 17'b00000000000000001;
          end
        end
      end
    end



  assign #1 Selector_out1_addr_delay_1 = Selector_out1_addr;

  // Data source for pixelInR
  initial
    begin : pixelInR_fileread
      fp_pixelInR = $fopen("pixelInR.dat", "r");
      status_pixelInR = $rewind(fp_pixelInR);
    end

  always @(Selector_out1_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_pixelInR <= 8'bx;
      end
      else if (rdEnb == 1) begin
        status_pixelInR = $fscanf(fp_pixelInR, "%h", rawData_pixelInR);
      end
    end

  // holdData reg for Selector_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Selector_out1
      if (reset) begin
        holdData_pixelInR <= 8'bx;
      end
      else begin
        holdData_pixelInR <= rawData_pixelInR;
      end
    end

  always @(rawData_pixelInR or rdEnb)
    begin : stimuli_Selector_out1_1
      if (rdEnb == 1'b0) begin
        pixelInR_offset <= holdData_pixelInR;
      end
      else begin
        pixelInR_offset <= rawData_pixelInR;
      end
    end

  assign #2 pixelInR = pixelInR_offset;

  assign snkDonen =  ~ snkDone;



  assign resetn =  ~ reset;



  assign tb_enb = resetn & snkDonen;



  // Delay inside enable generation: register depth 1
  always @(posedge clk or posedge reset)
    begin : u_enable_delay
      if (reset) begin
        tb_enb_delay <= 0;
      end
      else begin
        tb_enb_delay <= tb_enb;
      end
    end

  assign rdEnb = (snkDone == 1'b0 ? tb_enb_delay :
              1'b0);



  assign #2 clk_enable = rdEnb;

  initial
    begin : reset_gen
      reset <= 1'b1;
      # (20);
      @ (posedge clk)
      # (2);
      reset <= 1'b0;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  BlobDetector u_BlobDetector (.clk(clk),
                               .reset(reset),
                               .clk_enable(clk_enable),
                               .pixelInR(pixelInR),  // uint8
                               .pixelInG(pixelInG),  // uint8
                               .pixelInB(pixelInB),  // uint8
                               .ctrlIn_hStart(ctrlIn_hStart),
                               .ctrlIn_hEnd(ctrlIn_hEnd),
                               .ctrlIn_vStart(ctrlIn_vStart),
                               .ctrlIn_vEnd(ctrlIn_vEnd),
                               .ctrlIn_valid(ctrlIn_valid),
                               .GradThresh(GradThresh_1),  // uint8
                               .AreaThresh(AreaThresh_1),  // uint32
                               .CloseOp(CloseOp_1),
                               .VideoMode(VideoMode_1),  // uint8
                               .blobIndex(blobIndex),  // ufix10
                               .ce_out(ce_out),
                               .pixelOutR(pixelOutR),  // uint8
                               .pixelOutG(pixelOutG),  // uint8
                               .pixelOutB(pixelOutB),  // uint8
                               .ctrlOut_hStart(ctrlOut_hStart),
                               .ctrlOut_hEnd(ctrlOut_hEnd),
                               .ctrlOut_vStart(ctrlOut_vStart),
                               .ctrlOut_vEnd(ctrlOut_vEnd),
                               .ctrlOut_valid(ctrlOut_valid),
                               .x_o(x_o),  // uint16
                               .y_o(y_o),  // uint16
                               .area_o(area_o),  // ufix17
                               .bbox_x1_o(bbox_x1_o),  // ufix9
                               .bbox_y1_o(bbox_y1_o),  // uint8
                               .bbox_x2_o(bbox_x2_o),  // ufix9
                               .bbox_y2_o(bbox_y2_o),  // uint8
                               .fbidx_o(fbidx_o),  // ufix10
                               .num_o(num_o),  // uint16
                               .data_ready_o(data_ready_o),
                               .totalNum_o(totalNum_o)  // uint16
                               );

  assign pixelOutR_enb = ce_out & pixelOutR_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 130248
  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        pixelOutR_addr <= 17'b00000000000000000;
      end
      else begin
        if (pixelOutR_enb) begin
          if (pixelOutR_addr >= 17'b11111110011001000) begin
            pixelOutR_addr <= 17'b00000000000000000;
          end
          else begin
            pixelOutR_addr <= pixelOutR_addr + 17'b00000000000000001;
          end
        end
      end
    end



  assign pixelOutR_lastAddr = pixelOutR_addr >= 17'b11111110011001000;



  assign pixelOutR_done = pixelOutR_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_1
      if (reset) begin
        check1_done <= 0;
      end
      else begin
        if (pixelOutR_done_enb) begin
          check1_done <= pixelOutR_done;
        end
      end
    end

  always @(check10_done, check11_done, check12_done, check13_done, check14_done,
       check15_done, check16_done, check17_done, check18_done, check19_done,
       check1_done, check2_done, check3_done, check4_done, check5_done,
       check6_done, check7_done, check8_done, check9_done) begin
    snkDone = check19_done & (check18_done & (check17_done & (check16_done & (check15_done & (check14_done & (check13_done & (check12_done & (check11_done & (check10_done & (check9_done & (check8_done & (check7_done & (check6_done & (check5_done & (check4_done & (check3_done & (check1_done & check2_done)))))))))))))))));
  end



  assign pixelOutR_ignCntDone = pixelOutR_chkcnt != 4'b1011;



  assign pixelOutR_needToCount = ce_out & pixelOutR_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : pixelOutR_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        pixelOutR_chkcnt <= 4'b0000;
      end
      else begin
        if (pixelOutR_needToCount) begin
          if (pixelOutR_chkcnt >= 4'b1011) begin
            pixelOutR_chkcnt <= 4'b0000;
          end
          else begin
            pixelOutR_chkcnt <= pixelOutR_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign pixelOutR_chkenb = pixelOutR_chkcnt == 4'b1011;



  assign pixelOutR_chkdata = ce_out & pixelOutR_chkenb;



  assign #1 pixelOutR_addr_delay_1 = pixelOutR_addr;

  // Data source for pixelOutR_expected
  initial
    begin : pixelOutR_expected_fileread
      fp_pixelOutR_expected = $fopen("pixelOutR_expected.dat", "r");
      status_pixelOutR_expected = $rewind(fp_pixelOutR_expected);
    end

  always @(pixelOutR_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        pixelOutR_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_pixelOutR_expected = $fscanf(fp_pixelOutR_expected, "%h", pixelOutR_expected);
      end
    end

  assign pixelOutR_ref = pixelOutR_expected;

  always @(posedge clk or posedge reset)
    begin : pixelOutR_checker
      if (reset == 1'b1) begin
        pixelOutR_testFailure <= 1'b0;
      end
      else begin
        if (pixelOutR_chkdata == 1'b1 && pixelOutR !== pixelOutR_ref) begin
          pixelOutR_testFailure <= 1'b1;
          $display("ERROR in pixelOutR at time %t : Expected '%h' Actual '%h'", $time, pixelOutR_ref, pixelOutR);
        end
      end
    end

  assign pixelOutG_ignCntDone = pixelOutG_chkcnt != 4'b1011;



  assign pixelOutG_needToCount = ce_out & pixelOutG_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : pixelOutG_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        pixelOutG_chkcnt <= 4'b0000;
      end
      else begin
        if (pixelOutG_needToCount) begin
          if (pixelOutG_chkcnt >= 4'b1011) begin
            pixelOutG_chkcnt <= 4'b0000;
          end
          else begin
            pixelOutG_chkcnt <= pixelOutG_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign pixelOutG_chkenb = pixelOutG_chkcnt == 4'b1011;



  assign pixelOutG_chkdata = ce_out & pixelOutG_chkenb;



  assign #1 pixelOutG_addr_delay_1 = pixelOutR_addr;

  // Data source for pixelOutG_expected
  initial
    begin : pixelOutG_expected_fileread
      fp_pixelOutG_expected = $fopen("pixelOutG_expected.dat", "r");
      status_pixelOutG_expected = $rewind(fp_pixelOutG_expected);
    end

  always @(pixelOutG_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        pixelOutG_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_pixelOutG_expected = $fscanf(fp_pixelOutG_expected, "%h", pixelOutG_expected);
      end
    end

  assign pixelOutG_ref = pixelOutG_expected;

  always @(posedge clk or posedge reset)
    begin : pixelOutG_checker
      if (reset == 1'b1) begin
        pixelOutG_testFailure <= 1'b0;
      end
      else begin
        if (pixelOutG_chkdata == 1'b1 && pixelOutG !== pixelOutG_ref) begin
          pixelOutG_testFailure <= 1'b1;
          $display("ERROR in pixelOutG at time %t : Expected '%h' Actual '%h'", $time, pixelOutG_ref, pixelOutG);
        end
      end
    end

  assign pixelOutB_ignCntDone = pixelOutB_chkcnt != 4'b1011;



  assign pixelOutB_needToCount = ce_out & pixelOutB_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : pixelOutB_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        pixelOutB_chkcnt <= 4'b0000;
      end
      else begin
        if (pixelOutB_needToCount) begin
          if (pixelOutB_chkcnt >= 4'b1011) begin
            pixelOutB_chkcnt <= 4'b0000;
          end
          else begin
            pixelOutB_chkcnt <= pixelOutB_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign pixelOutB_chkenb = pixelOutB_chkcnt == 4'b1011;



  assign pixelOutB_chkdata = ce_out & pixelOutB_chkenb;



  // Data source for pixelOutB_expected
  assign pixelOutB_expected_1 = 8'b00000000;



  assign pixelOutB_ref = pixelOutB_expected_1;

  always @(posedge clk or posedge reset)
    begin : pixelOutB_checker
      if (reset == 1'b1) begin
        pixelOutB_testFailure <= 1'b0;
      end
      else begin
        if (pixelOutB_chkdata == 1'b1 && pixelOutB !== pixelOutB_ref) begin
          pixelOutB_testFailure <= 1'b1;
          $display("ERROR in pixelOutB at time %t : Expected '%h' Actual '%h'", $time, pixelOutB_ref, pixelOutB);
        end
      end
    end

  assign ctrlOut_hStart_ignCntDone = ctrlOut_hStart_chkcnt != 4'b1011;



  assign ctrlOut_hStart_needToCount = ce_out & ctrlOut_hStart_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : ctrlOut_hStart_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        ctrlOut_hStart_chkcnt <= 4'b0000;
      end
      else begin
        if (ctrlOut_hStart_needToCount) begin
          if (ctrlOut_hStart_chkcnt >= 4'b1011) begin
            ctrlOut_hStart_chkcnt <= 4'b0000;
          end
          else begin
            ctrlOut_hStart_chkcnt <= ctrlOut_hStart_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign ctrlOut_hStart_chkenb = ctrlOut_hStart_chkcnt == 4'b1011;



  assign ctrlOut_hStart_chkdata = ce_out & ctrlOut_hStart_chkenb;



  assign #1 ctrlOut_hStart_addr_delay_1 = pixelOutR_addr;

  // Data source for ctrlOut_hStart_expected
  initial
    begin : ctrlOut_hStart_expected_fileread
      fp_ctrlOut_hStart_expected = $fopen("ctrlOut_hStart_expected.dat", "r");
      status_ctrlOut_hStart_expected = $rewind(fp_ctrlOut_hStart_expected);
    end

  always @(ctrlOut_hStart_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_hStart_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_hStart_expected = $fscanf(fp_ctrlOut_hStart_expected, "%h", ctrlOut_hStart_expected);
      end
    end

  assign ctrlOut_hStart_ref = ctrlOut_hStart_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_hStart_checker
      if (reset == 1'b1) begin
        ctrlOut_hStart_testFailure <= 1'b0;
      end
      else begin
        if (ctrlOut_hStart_chkdata == 1'b1 && ctrlOut_hStart !== ctrlOut_hStart_ref) begin
          ctrlOut_hStart_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_hStart at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_hStart_ref, ctrlOut_hStart);
        end
      end
    end

  assign ctrlOut_hEnd_ignCntDone = ctrlOut_hEnd_chkcnt != 4'b1011;



  assign ctrlOut_hEnd_needToCount = ce_out & ctrlOut_hEnd_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : ctrlOut_hEnd_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        ctrlOut_hEnd_chkcnt <= 4'b0000;
      end
      else begin
        if (ctrlOut_hEnd_needToCount) begin
          if (ctrlOut_hEnd_chkcnt >= 4'b1011) begin
            ctrlOut_hEnd_chkcnt <= 4'b0000;
          end
          else begin
            ctrlOut_hEnd_chkcnt <= ctrlOut_hEnd_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign ctrlOut_hEnd_chkenb = ctrlOut_hEnd_chkcnt == 4'b1011;



  assign ctrlOut_hEnd_chkdata = ce_out & ctrlOut_hEnd_chkenb;



  assign #1 ctrlOut_hEnd_addr_delay_1 = pixelOutR_addr;

  // Data source for ctrlOut_hEnd_expected
  initial
    begin : ctrlOut_hEnd_expected_fileread
      fp_ctrlOut_hEnd_expected = $fopen("ctrlOut_hEnd_expected.dat", "r");
      status_ctrlOut_hEnd_expected = $rewind(fp_ctrlOut_hEnd_expected);
    end

  always @(ctrlOut_hEnd_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_hEnd_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_hEnd_expected = $fscanf(fp_ctrlOut_hEnd_expected, "%h", ctrlOut_hEnd_expected);
      end
    end

  assign ctrlOut_hEnd_ref = ctrlOut_hEnd_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_hEnd_checker
      if (reset == 1'b1) begin
        ctrlOut_hEnd_testFailure <= 1'b0;
      end
      else begin
        if (ctrlOut_hEnd_chkdata == 1'b1 && ctrlOut_hEnd !== ctrlOut_hEnd_ref) begin
          ctrlOut_hEnd_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_hEnd at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_hEnd_ref, ctrlOut_hEnd);
        end
      end
    end

  assign ctrlOut_vStart_ignCntDone = ctrlOut_vStart_chkcnt != 4'b1011;



  assign ctrlOut_vStart_needToCount = ce_out & ctrlOut_vStart_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : ctrlOut_vStart_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        ctrlOut_vStart_chkcnt <= 4'b0000;
      end
      else begin
        if (ctrlOut_vStart_needToCount) begin
          if (ctrlOut_vStart_chkcnt >= 4'b1011) begin
            ctrlOut_vStart_chkcnt <= 4'b0000;
          end
          else begin
            ctrlOut_vStart_chkcnt <= ctrlOut_vStart_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign ctrlOut_vStart_chkenb = ctrlOut_vStart_chkcnt == 4'b1011;



  assign ctrlOut_vStart_chkdata = ce_out & ctrlOut_vStart_chkenb;



  assign #1 ctrlOut_vStart_addr_delay_1 = pixelOutR_addr;

  // Data source for ctrlOut_vStart_expected
  initial
    begin : ctrlOut_vStart_expected_fileread
      fp_ctrlOut_vStart_expected = $fopen("ctrlOut_vStart_expected.dat", "r");
      status_ctrlOut_vStart_expected = $rewind(fp_ctrlOut_vStart_expected);
    end

  always @(ctrlOut_vStart_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_vStart_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_vStart_expected = $fscanf(fp_ctrlOut_vStart_expected, "%h", ctrlOut_vStart_expected);
      end
    end

  assign ctrlOut_vStart_ref = ctrlOut_vStart_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_vStart_checker
      if (reset == 1'b1) begin
        ctrlOut_vStart_testFailure <= 1'b0;
      end
      else begin
        if (ctrlOut_vStart_chkdata == 1'b1 && ctrlOut_vStart !== ctrlOut_vStart_ref) begin
          ctrlOut_vStart_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_vStart at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_vStart_ref, ctrlOut_vStart);
        end
      end
    end

  assign ctrlOut_vEnd_ignCntDone = ctrlOut_vEnd_chkcnt != 4'b1011;



  assign ctrlOut_vEnd_needToCount = ce_out & ctrlOut_vEnd_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : ctrlOut_vEnd_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        ctrlOut_vEnd_chkcnt <= 4'b0000;
      end
      else begin
        if (ctrlOut_vEnd_needToCount) begin
          if (ctrlOut_vEnd_chkcnt >= 4'b1011) begin
            ctrlOut_vEnd_chkcnt <= 4'b0000;
          end
          else begin
            ctrlOut_vEnd_chkcnt <= ctrlOut_vEnd_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign ctrlOut_vEnd_chkenb = ctrlOut_vEnd_chkcnt == 4'b1011;



  assign ctrlOut_vEnd_chkdata = ce_out & ctrlOut_vEnd_chkenb;



  assign #1 ctrlOut_vEnd_addr_delay_1 = pixelOutR_addr;

  // Data source for ctrlOut_vEnd_expected
  initial
    begin : ctrlOut_vEnd_expected_fileread
      fp_ctrlOut_vEnd_expected = $fopen("ctrlOut_vEnd_expected.dat", "r");
      status_ctrlOut_vEnd_expected = $rewind(fp_ctrlOut_vEnd_expected);
    end

  always @(ctrlOut_vEnd_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_vEnd_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_vEnd_expected = $fscanf(fp_ctrlOut_vEnd_expected, "%h", ctrlOut_vEnd_expected);
      end
    end

  assign ctrlOut_vEnd_ref = ctrlOut_vEnd_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_vEnd_checker
      if (reset == 1'b1) begin
        ctrlOut_vEnd_testFailure <= 1'b0;
      end
      else begin
        if (ctrlOut_vEnd_chkdata == 1'b1 && ctrlOut_vEnd !== ctrlOut_vEnd_ref) begin
          ctrlOut_vEnd_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_vEnd at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_vEnd_ref, ctrlOut_vEnd);
        end
      end
    end

  assign ctrlOut_valid_ignCntDone = ctrlOut_valid_chkcnt != 4'b1011;



  assign ctrlOut_valid_needToCount = ce_out & ctrlOut_valid_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : ctrlOut_valid_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        ctrlOut_valid_chkcnt <= 4'b0000;
      end
      else begin
        if (ctrlOut_valid_needToCount) begin
          if (ctrlOut_valid_chkcnt >= 4'b1011) begin
            ctrlOut_valid_chkcnt <= 4'b0000;
          end
          else begin
            ctrlOut_valid_chkcnt <= ctrlOut_valid_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign ctrlOut_valid_chkenb = ctrlOut_valid_chkcnt == 4'b1011;



  assign ctrlOut_valid_chkdata = ce_out & ctrlOut_valid_chkenb;



  assign #1 ctrlOut_valid_addr_delay_1 = pixelOutR_addr;

  // Data source for ctrlOut_valid_expected
  initial
    begin : ctrlOut_valid_expected_fileread
      fp_ctrlOut_valid_expected = $fopen("ctrlOut_valid_expected.dat", "r");
      status_ctrlOut_valid_expected = $rewind(fp_ctrlOut_valid_expected);
    end

  always @(ctrlOut_valid_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_valid_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_valid_expected = $fscanf(fp_ctrlOut_valid_expected, "%h", ctrlOut_valid_expected);
      end
    end

  assign ctrlOut_valid_ref = ctrlOut_valid_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_valid_checker
      if (reset == 1'b1) begin
        ctrlOut_valid_testFailure <= 1'b0;
      end
      else begin
        if (ctrlOut_valid_chkdata == 1'b1 && ctrlOut_valid !== ctrlOut_valid_ref) begin
          ctrlOut_valid_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_valid at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_valid_ref, ctrlOut_valid);
        end
      end
    end

  assign x_o_ignCntDone = x_o_chkcnt != 4'b1011;



  assign x_o_needToCount = ce_out & x_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : x_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        x_o_chkcnt <= 4'b0000;
      end
      else begin
        if (x_o_needToCount) begin
          if (x_o_chkcnt >= 4'b1011) begin
            x_o_chkcnt <= 4'b0000;
          end
          else begin
            x_o_chkcnt <= x_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign x_o_chkenb = x_o_chkcnt == 4'b1011;



  assign x_o_chkdata = ce_out & x_o_chkenb;



  assign #1 x_o_addr_delay_1 = pixelOutR_addr;

  // Data source for x_o_expected
  initial
    begin : x_o_expected_fileread
      fp_x_o_expected = $fopen("x_o_expected.dat", "r");
      status_x_o_expected = $rewind(fp_x_o_expected);
    end

  always @(x_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        x_o_expected <= 16'bx;
      end
      else if (ce_out == 1) begin
        status_x_o_expected = $fscanf(fp_x_o_expected, "%h", x_o_expected);
      end
    end

  assign x_o_ref = x_o_expected;

  always @(posedge clk or posedge reset)
    begin : x_o_checker
      if (reset == 1'b1) begin
        x_o_testFailure <= 1'b0;
      end
      else begin
        if (x_o_chkdata == 1'b1 && x_o !== x_o_ref) begin
          x_o_testFailure <= 1'b1;
          $display("ERROR in x_o at time %t : Expected '%h' Actual '%h'", $time, x_o_ref, x_o);
        end
      end
    end

  assign y_o_ignCntDone = y_o_chkcnt != 4'b1011;



  assign y_o_needToCount = ce_out & y_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : y_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        y_o_chkcnt <= 4'b0000;
      end
      else begin
        if (y_o_needToCount) begin
          if (y_o_chkcnt >= 4'b1011) begin
            y_o_chkcnt <= 4'b0000;
          end
          else begin
            y_o_chkcnt <= y_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign y_o_chkenb = y_o_chkcnt == 4'b1011;



  assign y_o_chkdata = ce_out & y_o_chkenb;



  assign #1 y_o_addr_delay_1 = pixelOutR_addr;

  // Data source for y_o_expected
  initial
    begin : y_o_expected_fileread
      fp_y_o_expected = $fopen("y_o_expected.dat", "r");
      status_y_o_expected = $rewind(fp_y_o_expected);
    end

  always @(y_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        y_o_expected <= 16'bx;
      end
      else if (ce_out == 1) begin
        status_y_o_expected = $fscanf(fp_y_o_expected, "%h", y_o_expected);
      end
    end

  assign y_o_ref = y_o_expected;

  always @(posedge clk or posedge reset)
    begin : y_o_checker
      if (reset == 1'b1) begin
        y_o_testFailure <= 1'b0;
      end
      else begin
        if (y_o_chkdata == 1'b1 && y_o !== y_o_ref) begin
          y_o_testFailure <= 1'b1;
          $display("ERROR in y_o at time %t : Expected '%h' Actual '%h'", $time, y_o_ref, y_o);
        end
      end
    end

  assign area_o_ignCntDone = area_o_chkcnt != 4'b1011;



  assign area_o_needToCount = ce_out & area_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : area_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        area_o_chkcnt <= 4'b0000;
      end
      else begin
        if (area_o_needToCount) begin
          if (area_o_chkcnt >= 4'b1011) begin
            area_o_chkcnt <= 4'b0000;
          end
          else begin
            area_o_chkcnt <= area_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign area_o_chkenb = area_o_chkcnt == 4'b1011;



  assign area_o_chkdata = ce_out & area_o_chkenb;



  assign #1 area_o_addr_delay_1 = pixelOutR_addr;

  // Data source for area_o_expected
  initial
    begin : area_o_expected_fileread
      fp_area_o_expected = $fopen("area_o_expected.dat", "r");
      status_area_o_expected = $rewind(fp_area_o_expected);
    end

  always @(area_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        area_o_expected <= 17'bx;
      end
      else if (ce_out == 1) begin
        status_area_o_expected = $fscanf(fp_area_o_expected, "%h", area_o_expected);
      end
    end

  assign area_o_ref = area_o_expected;

  always @(posedge clk or posedge reset)
    begin : area_o_checker
      if (reset == 1'b1) begin
        area_o_testFailure <= 1'b0;
      end
      else begin
        if (area_o_chkdata == 1'b1 && area_o !== area_o_ref) begin
          area_o_testFailure <= 1'b1;
          $display("ERROR in area_o at time %t : Expected '%h' Actual '%h'", $time, area_o_ref, area_o);
        end
      end
    end

  assign bbox_x1_o_ignCntDone = bbox_x1_o_chkcnt != 4'b1011;



  assign bbox_x1_o_needToCount = ce_out & bbox_x1_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : bbox_x1_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        bbox_x1_o_chkcnt <= 4'b0000;
      end
      else begin
        if (bbox_x1_o_needToCount) begin
          if (bbox_x1_o_chkcnt >= 4'b1011) begin
            bbox_x1_o_chkcnt <= 4'b0000;
          end
          else begin
            bbox_x1_o_chkcnt <= bbox_x1_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign bbox_x1_o_chkenb = bbox_x1_o_chkcnt == 4'b1011;



  assign bbox_x1_o_chkdata = ce_out & bbox_x1_o_chkenb;



  assign #1 bbox_x1_o_addr_delay_1 = pixelOutR_addr;

  // Data source for bbox_x1_o_expected
  initial
    begin : bbox_x1_o_expected_fileread
      fp_bbox_x1_o_expected = $fopen("bbox_x1_o_expected.dat", "r");
      status_bbox_x1_o_expected = $rewind(fp_bbox_x1_o_expected);
    end

  always @(bbox_x1_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bbox_x1_o_expected <= 9'bx;
      end
      else if (ce_out == 1) begin
        status_bbox_x1_o_expected = $fscanf(fp_bbox_x1_o_expected, "%h", bbox_x1_o_expected);
      end
    end

  assign bbox_x1_o_ref = bbox_x1_o_expected;

  always @(posedge clk or posedge reset)
    begin : bbox_x1_o_checker
      if (reset == 1'b1) begin
        bbox_x1_o_testFailure <= 1'b0;
      end
      else begin
        if (bbox_x1_o_chkdata == 1'b1 && bbox_x1_o !== bbox_x1_o_ref) begin
          bbox_x1_o_testFailure <= 1'b1;
          $display("ERROR in bbox_x1_o at time %t : Expected '%h' Actual '%h'", $time, bbox_x1_o_ref, bbox_x1_o);
        end
      end
    end

  assign bbox_y1_o_ignCntDone = bbox_y1_o_chkcnt != 4'b1011;



  assign bbox_y1_o_needToCount = ce_out & bbox_y1_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : bbox_y1_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        bbox_y1_o_chkcnt <= 4'b0000;
      end
      else begin
        if (bbox_y1_o_needToCount) begin
          if (bbox_y1_o_chkcnt >= 4'b1011) begin
            bbox_y1_o_chkcnt <= 4'b0000;
          end
          else begin
            bbox_y1_o_chkcnt <= bbox_y1_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign bbox_y1_o_chkenb = bbox_y1_o_chkcnt == 4'b1011;



  assign bbox_y1_o_chkdata = ce_out & bbox_y1_o_chkenb;



  assign #1 bbox_y1_o_addr_delay_1 = pixelOutR_addr;

  // Data source for bbox_y1_o_expected
  initial
    begin : bbox_y1_o_expected_fileread
      fp_bbox_y1_o_expected = $fopen("bbox_y1_o_expected.dat", "r");
      status_bbox_y1_o_expected = $rewind(fp_bbox_y1_o_expected);
    end

  always @(bbox_y1_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bbox_y1_o_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_bbox_y1_o_expected = $fscanf(fp_bbox_y1_o_expected, "%h", bbox_y1_o_expected);
      end
    end

  assign bbox_y1_o_ref = bbox_y1_o_expected;

  always @(posedge clk or posedge reset)
    begin : bbox_y1_o_checker
      if (reset == 1'b1) begin
        bbox_y1_o_testFailure <= 1'b0;
      end
      else begin
        if (bbox_y1_o_chkdata == 1'b1 && bbox_y1_o !== bbox_y1_o_ref) begin
          bbox_y1_o_testFailure <= 1'b1;
          $display("ERROR in bbox_y1_o at time %t : Expected '%h' Actual '%h'", $time, bbox_y1_o_ref, bbox_y1_o);
        end
      end
    end

  assign bbox_x2_o_ignCntDone = bbox_x2_o_chkcnt != 4'b1011;



  assign bbox_x2_o_needToCount = ce_out & bbox_x2_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : bbox_x2_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        bbox_x2_o_chkcnt <= 4'b0000;
      end
      else begin
        if (bbox_x2_o_needToCount) begin
          if (bbox_x2_o_chkcnt >= 4'b1011) begin
            bbox_x2_o_chkcnt <= 4'b0000;
          end
          else begin
            bbox_x2_o_chkcnt <= bbox_x2_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign bbox_x2_o_chkenb = bbox_x2_o_chkcnt == 4'b1011;



  assign bbox_x2_o_chkdata = ce_out & bbox_x2_o_chkenb;



  assign #1 bbox_x2_o_addr_delay_1 = pixelOutR_addr;

  // Data source for bbox_x2_o_expected
  initial
    begin : bbox_x2_o_expected_fileread
      fp_bbox_x2_o_expected = $fopen("bbox_x2_o_expected.dat", "r");
      status_bbox_x2_o_expected = $rewind(fp_bbox_x2_o_expected);
    end

  always @(bbox_x2_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bbox_x2_o_expected <= 9'bx;
      end
      else if (ce_out == 1) begin
        status_bbox_x2_o_expected = $fscanf(fp_bbox_x2_o_expected, "%h", bbox_x2_o_expected);
      end
    end

  assign bbox_x2_o_ref = bbox_x2_o_expected;

  always @(posedge clk or posedge reset)
    begin : bbox_x2_o_checker
      if (reset == 1'b1) begin
        bbox_x2_o_testFailure <= 1'b0;
      end
      else begin
        if (bbox_x2_o_chkdata == 1'b1 && bbox_x2_o !== bbox_x2_o_ref) begin
          bbox_x2_o_testFailure <= 1'b1;
          $display("ERROR in bbox_x2_o at time %t : Expected '%h' Actual '%h'", $time, bbox_x2_o_ref, bbox_x2_o);
        end
      end
    end

  assign bbox_y2_o_ignCntDone = bbox_y2_o_chkcnt != 4'b1011;



  assign bbox_y2_o_needToCount = ce_out & bbox_y2_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : bbox_y2_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        bbox_y2_o_chkcnt <= 4'b0000;
      end
      else begin
        if (bbox_y2_o_needToCount) begin
          if (bbox_y2_o_chkcnt >= 4'b1011) begin
            bbox_y2_o_chkcnt <= 4'b0000;
          end
          else begin
            bbox_y2_o_chkcnt <= bbox_y2_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign bbox_y2_o_chkenb = bbox_y2_o_chkcnt == 4'b1011;



  assign bbox_y2_o_chkdata = ce_out & bbox_y2_o_chkenb;



  assign #1 bbox_y2_o_addr_delay_1 = pixelOutR_addr;

  // Data source for bbox_y2_o_expected
  initial
    begin : bbox_y2_o_expected_fileread
      fp_bbox_y2_o_expected = $fopen("bbox_y2_o_expected.dat", "r");
      status_bbox_y2_o_expected = $rewind(fp_bbox_y2_o_expected);
    end

  always @(bbox_y2_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bbox_y2_o_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_bbox_y2_o_expected = $fscanf(fp_bbox_y2_o_expected, "%h", bbox_y2_o_expected);
      end
    end

  assign bbox_y2_o_ref = bbox_y2_o_expected;

  always @(posedge clk or posedge reset)
    begin : bbox_y2_o_checker
      if (reset == 1'b1) begin
        bbox_y2_o_testFailure <= 1'b0;
      end
      else begin
        if (bbox_y2_o_chkdata == 1'b1 && bbox_y2_o !== bbox_y2_o_ref) begin
          bbox_y2_o_testFailure <= 1'b1;
          $display("ERROR in bbox_y2_o at time %t : Expected '%h' Actual '%h'", $time, bbox_y2_o_ref, bbox_y2_o);
        end
      end
    end

  assign fbidx_o_ignCntDone = fbidx_o_chkcnt != 4'b1011;



  assign fbidx_o_needToCount = ce_out & fbidx_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : fbidx_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        fbidx_o_chkcnt <= 4'b0000;
      end
      else begin
        if (fbidx_o_needToCount) begin
          if (fbidx_o_chkcnt >= 4'b1011) begin
            fbidx_o_chkcnt <= 4'b0000;
          end
          else begin
            fbidx_o_chkcnt <= fbidx_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign fbidx_o_chkenb = fbidx_o_chkcnt == 4'b1011;



  assign fbidx_o_chkdata = ce_out & fbidx_o_chkenb;



  assign #1 fbidx_o_addr_delay_1 = pixelOutR_addr;

  // Data source for fbidx_o_expected
  initial
    begin : fbidx_o_expected_fileread
      fp_fbidx_o_expected = $fopen("fbidx_o_expected.dat", "r");
      status_fbidx_o_expected = $rewind(fp_fbidx_o_expected);
    end

  always @(fbidx_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        fbidx_o_expected <= 10'bx;
      end
      else if (ce_out == 1) begin
        status_fbidx_o_expected = $fscanf(fp_fbidx_o_expected, "%h", fbidx_o_expected);
      end
    end

  assign fbidx_o_ref = fbidx_o_expected;

  always @(posedge clk or posedge reset)
    begin : fbidx_o_checker
      if (reset == 1'b1) begin
        fbidx_o_testFailure <= 1'b0;
      end
      else begin
        if (fbidx_o_chkdata == 1'b1 && fbidx_o !== fbidx_o_ref) begin
          fbidx_o_testFailure <= 1'b1;
          $display("ERROR in fbidx_o at time %t : Expected '%h' Actual '%h'", $time, fbidx_o_ref, fbidx_o);
        end
      end
    end

  assign num_o_ignCntDone = num_o_chkcnt != 4'b1011;



  assign num_o_needToCount = ce_out & num_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : num_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        num_o_chkcnt <= 4'b0000;
      end
      else begin
        if (num_o_needToCount) begin
          if (num_o_chkcnt >= 4'b1011) begin
            num_o_chkcnt <= 4'b0000;
          end
          else begin
            num_o_chkcnt <= num_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign num_o_chkenb = num_o_chkcnt == 4'b1011;



  assign num_o_chkdata = ce_out & num_o_chkenb;



  assign #1 num_o_addr_delay_1 = pixelOutR_addr;

  // Data source for num_o_expected
  initial
    begin : num_o_expected_fileread
      fp_num_o_expected = $fopen("num_o_expected.dat", "r");
      status_num_o_expected = $rewind(fp_num_o_expected);
    end

  always @(num_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        num_o_expected <= 16'bx;
      end
      else if (ce_out == 1) begin
        status_num_o_expected = $fscanf(fp_num_o_expected, "%h", num_o_expected);
      end
    end

  assign num_o_ref = num_o_expected;

  always @(posedge clk or posedge reset)
    begin : num_o_checker
      if (reset == 1'b1) begin
        num_o_testFailure <= 1'b0;
      end
      else begin
        if (num_o_chkdata == 1'b1 && num_o !== num_o_ref) begin
          num_o_testFailure <= 1'b1;
          $display("ERROR in num_o at time %t : Expected '%h' Actual '%h'", $time, num_o_ref, num_o);
        end
      end
    end

  assign data_ready_o_ignCntDone = data_ready_o_chkcnt != 4'b1011;



  assign data_ready_o_needToCount = ce_out & data_ready_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : data_ready_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        data_ready_o_chkcnt <= 4'b0000;
      end
      else begin
        if (data_ready_o_needToCount) begin
          if (data_ready_o_chkcnt >= 4'b1011) begin
            data_ready_o_chkcnt <= 4'b0000;
          end
          else begin
            data_ready_o_chkcnt <= data_ready_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign data_ready_o_chkenb = data_ready_o_chkcnt == 4'b1011;



  assign data_ready_o_chkdata = ce_out & data_ready_o_chkenb;



  assign #1 data_ready_o_addr_delay_1 = pixelOutR_addr;

  // Data source for data_ready_o_expected
  initial
    begin : data_ready_o_expected_fileread
      fp_data_ready_o_expected = $fopen("data_ready_o_expected.dat", "r");
      status_data_ready_o_expected = $rewind(fp_data_ready_o_expected);
    end

  always @(data_ready_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        data_ready_o_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_data_ready_o_expected = $fscanf(fp_data_ready_o_expected, "%h", data_ready_o_expected);
      end
    end

  assign data_ready_o_ref = data_ready_o_expected;

  always @(posedge clk or posedge reset)
    begin : data_ready_o_checker
      if (reset == 1'b1) begin
        data_ready_o_testFailure <= 1'b0;
      end
      else begin
        if (data_ready_o_chkdata == 1'b1 && data_ready_o !== data_ready_o_ref) begin
          data_ready_o_testFailure <= 1'b1;
          $display("ERROR in data_ready_o at time %t : Expected '%h' Actual '%h'", $time, data_ready_o_ref, data_ready_o);
        end
      end
    end

  assign totalNum_o_ignCntDone = totalNum_o_chkcnt != 4'b1011;



  assign totalNum_o_needToCount = ce_out & totalNum_o_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  always @(posedge clk or posedge reset)
    begin : totalNum_o_IgnoreDataChecking_process
      if (reset == 1'b1) begin
        totalNum_o_chkcnt <= 4'b0000;
      end
      else begin
        if (totalNum_o_needToCount) begin
          if (totalNum_o_chkcnt >= 4'b1011) begin
            totalNum_o_chkcnt <= 4'b0000;
          end
          else begin
            totalNum_o_chkcnt <= totalNum_o_chkcnt + 4'b0001;
          end
        end
      end
    end



  assign totalNum_o_chkenb = totalNum_o_chkcnt == 4'b1011;



  assign totalNum_o_chkdata = ce_out & totalNum_o_chkenb;



  assign #1 totalNum_o_addr_delay_1 = pixelOutR_addr;

  // Data source for totalNum_o_expected
  initial
    begin : totalNum_o_expected_fileread
      fp_totalNum_o_expected = $fopen("totalNum_o_expected.dat", "r");
      status_totalNum_o_expected = $rewind(fp_totalNum_o_expected);
    end

  always @(totalNum_o_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        totalNum_o_expected <= 16'bx;
      end
      else if (ce_out == 1) begin
        status_totalNum_o_expected = $fscanf(fp_totalNum_o_expected, "%h", totalNum_o_expected);
      end
    end

  assign totalNum_o_ref = totalNum_o_expected;

  always @(posedge clk or posedge reset)
    begin : totalNum_o_checker
      if (reset == 1'b1) begin
        totalNum_o_testFailure <= 1'b0;
      end
      else begin
        if (totalNum_o_chkdata == 1'b1 && totalNum_o !== totalNum_o_ref) begin
          totalNum_o_testFailure <= 1'b1;
          $display("ERROR in totalNum_o at time %t : Expected '%h' Actual '%h'", $time, totalNum_o_ref, totalNum_o);
        end
      end
    end

  always @(area_o_testFailure, bbox_x1_o_testFailure, bbox_x2_o_testFailure,
       bbox_y1_o_testFailure, bbox_y2_o_testFailure, ctrlOut_hEnd_testFailure,
       ctrlOut_hStart_testFailure, ctrlOut_vEnd_testFailure,
       ctrlOut_vStart_testFailure, ctrlOut_valid_testFailure,
       data_ready_o_testFailure, fbidx_o_testFailure, num_o_testFailure,
       pixelOutB_testFailure, pixelOutG_testFailure, pixelOutR_testFailure,
       totalNum_o_testFailure, x_o_testFailure, y_o_testFailure) begin
    testFailure = totalNum_o_testFailure | (data_ready_o_testFailure | (num_o_testFailure | (fbidx_o_testFailure | (bbox_y2_o_testFailure | (bbox_x2_o_testFailure | (bbox_y1_o_testFailure | (bbox_x1_o_testFailure | (area_o_testFailure | (y_o_testFailure | (x_o_testFailure | (ctrlOut_valid_testFailure | (ctrlOut_vEnd_testFailure | (ctrlOut_vStart_testFailure | (ctrlOut_hEnd_testFailure | (ctrlOut_hStart_testFailure | (pixelOutB_testFailure | (pixelOutR_testFailure | pixelOutG_testFailure)))))))))))))))));
  end



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // BlobDetector_tb

