// -------------------------------------------------------------
// 
// File Name: C:\Users\team06\Documents\MATLAB\Examples\R2022b\visionhdl\BlobAnalysisExample\verilog_hdl\BlobAnalysisHDL\gatheroutput.v
// Created: 2022-12-23 11:30:02
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: gatheroutput
// Source Path: BlobAnalysisHDL/BlobDetector/CCA_Algorithm/gatheroutput
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module gatheroutput
          (clk,
           reset,
           enb,
           x_in,
           y_in,
           area_in,
           valid_in,
           numTotalBlobs_in,
           bbox_in,
           lastIdx_in,
           AreaMin_in,
           x_out,
           y_out,
           area_out,
           valid_out,
           bbox_out,
           numBlobs_out,
           numTotalBlobs_out);


  input   clk;
  input   reset;
  input   enb;
  input   [55:0] x_in;  // ufix56_En30
  input   [55:0] y_in;  // ufix56_En30
  input   [16:0] area_in;  // ufix17
  input   valid_in;
  input   [15:0] numTotalBlobs_in;  // uint16
  input   [33:0] bbox_in;  // ufix34
  input   lastIdx_in;
  input   [31:0] AreaMin_in;  // uint32
  output  [15:0] x_out;  // ufix16_En5
  output  [15:0] y_out;  // ufix16_En5
  output  [16:0] area_out;  // ufix17
  output  valid_out;
  output  [33:0] bbox_out;  // ufix34
  output  [15:0] numBlobs_out;  // uint16
  output  [15:0] numTotalBlobs_out;  // uint16


  wire [31:0] Relational_Operator_1_1;  // ufix32
  wire Relational_Operator_relop1;
  wire [33:0] includeBorder_out1;  // ufix34
  wire includeBorder_out1_is_not0;
  wire AND_out1;
  reg  [0:10] reduced_reg;  // ufix1 [11]
  wire [0:10] reduced_reg_next;  // ufix1 [11]
  wire AND_out1_1;
  wire [15:0] xC_out1;  // ufix16_En5
  wire [15:0] Data_Type_Conversion_out1;  // ufix16_En5
  wire [15:0] onebasedX_out1;  // ufix16_En5
  wire [15:0] Switch_out1;  // ufix16_En5
  wire [15:0] yC_out1;  // ufix16_En5
  wire [15:0] Data_Type_Conversion1_out1;  // ufix16_En5
  wire [15:0] onebasedY_out1;  // ufix16_En5
  wire [15:0] Switch1_out1;  // ufix16_En5
  wire [16:0] aC_out1;  // ufix17
  wire [16:0] Switch2_out1;  // ufix17
  wire [33:0] bbC_out1;  // ufix34
  wire [33:0] Switch3_out1;  // ufix34
  reg  Delay1_out1;
  reg  [0:1] Delay_reg;  // ufix1 [2]
  wire [0:1] Delay_reg_next;  // ufix1 [2]
  wire Delay_out1;
  wire [15:0] count_step;  // uint16
  wire [15:0] count_reset;  // uint16
  reg [15:0] HDL_Counter_out1;  // uint16
  wire [15:0] count;  // uint16
  wire [15:0] count_1;  // uint16
  wire [15:0] count_2;  // uint16
  reg [15:0] Delay2_out1;  // uint16
  wire [15:0] Delay2_ectrl;  // uint16
  reg [15:0] Delay3_out1;  // uint16
  wire [15:0] Delay3_ectrl;  // uint16


  assign Relational_Operator_1_1 = {15'b0, area_in};
  assign Relational_Operator_relop1 = Relational_Operator_1_1 >= AreaMin_in;



  includeBorder u_includeBorder (.In1(bbox_in),  // ufix34
                                 .Out1(includeBorder_out1)  // ufix34
                                 );

  assign includeBorder_out1_is_not0 = includeBorder_out1 != 34'h000000000;



  assign AND_out1 = includeBorder_out1_is_not0 & (valid_in & Relational_Operator_relop1);



  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        reduced_reg[0] <= 1'b0;
        reduced_reg[1] <= 1'b0;
        reduced_reg[2] <= 1'b0;
        reduced_reg[3] <= 1'b0;
        reduced_reg[4] <= 1'b0;
        reduced_reg[5] <= 1'b0;
        reduced_reg[6] <= 1'b0;
        reduced_reg[7] <= 1'b0;
        reduced_reg[8] <= 1'b0;
        reduced_reg[9] <= 1'b0;
        reduced_reg[10] <= 1'b0;
      end
      else begin
        if (enb) begin
          reduced_reg[0] <= reduced_reg_next[0];
          reduced_reg[1] <= reduced_reg_next[1];
          reduced_reg[2] <= reduced_reg_next[2];
          reduced_reg[3] <= reduced_reg_next[3];
          reduced_reg[4] <= reduced_reg_next[4];
          reduced_reg[5] <= reduced_reg_next[5];
          reduced_reg[6] <= reduced_reg_next[6];
          reduced_reg[7] <= reduced_reg_next[7];
          reduced_reg[8] <= reduced_reg_next[8];
          reduced_reg[9] <= reduced_reg_next[9];
          reduced_reg[10] <= reduced_reg_next[10];
        end
      end
    end

  assign AND_out1_1 = reduced_reg[10];
  assign reduced_reg_next[0] = AND_out1;
  assign reduced_reg_next[1] = reduced_reg[0];
  assign reduced_reg_next[2] = reduced_reg[1];
  assign reduced_reg_next[3] = reduced_reg[2];
  assign reduced_reg_next[4] = reduced_reg[3];
  assign reduced_reg_next[5] = reduced_reg[4];
  assign reduced_reg_next[6] = reduced_reg[5];
  assign reduced_reg_next[7] = reduced_reg[6];
  assign reduced_reg_next[8] = reduced_reg[7];
  assign reduced_reg_next[9] = reduced_reg[8];
  assign reduced_reg_next[10] = reduced_reg[9];



  assign xC_out1 = 16'b0000000000000000;



  assign Data_Type_Conversion_out1 = x_in[40:25];



  assign onebasedX_out1 = Data_Type_Conversion_out1 + 16'b0000000000100000;



  assign Switch_out1 = (AND_out1_1 == 1'b0 ? xC_out1 :
              onebasedX_out1);



  assign x_out = Switch_out1;

  assign yC_out1 = 16'b0000000000000000;



  assign Data_Type_Conversion1_out1 = y_in[40:25];



  assign onebasedY_out1 = Data_Type_Conversion1_out1 + 16'b0000000000100000;



  assign Switch1_out1 = (AND_out1_1 == 1'b0 ? yC_out1 :
              onebasedY_out1);



  assign y_out = Switch1_out1;

  assign aC_out1 = 17'b00000000000000000;



  assign Switch2_out1 = (AND_out1 == 1'b0 ? aC_out1 :
              area_in);



  assign area_out = Switch2_out1;

  assign valid_out = AND_out1;

  assign bbC_out1 = 34'h000000000;



  assign Switch3_out1 = (AND_out1 == 1'b0 ? bbC_out1 :
              bbox_in);



  assign bbox_out = Switch3_out1;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b1;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= lastIdx_in;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_reg[0] <= 1'b1;
        Delay_reg[1] <= 1'b1;
      end
      else begin
        if (enb) begin
          Delay_reg[0] <= Delay_reg_next[0];
          Delay_reg[1] <= Delay_reg_next[1];
        end
      end
    end

  assign Delay_out1 = Delay_reg[1];
  assign Delay_reg_next[0] = lastIdx_in;
  assign Delay_reg_next[1] = Delay_reg[0];



  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  assign count_step = 16'b0000000000000001;



  assign count_reset = 16'b0000000000000000;



  assign count = HDL_Counter_out1 + count_step;



  assign count_1 = (AND_out1 == 1'b0 ? HDL_Counter_out1 :
              count);



  assign count_2 = (Delay_out1 == 1'b0 ? count_1 :
              count_reset);



  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= count_2;
        end
      end
    end



  assign Delay2_ectrl = (Delay1_out1 == 1'b0 ? Delay2_out1 :
              HDL_Counter_out1);



  always @(posedge clk or posedge reset)
    begin : Delay2_lowered_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Delay2_ectrl;
        end
      end
    end



  assign numBlobs_out = Delay2_out1;

  assign Delay3_ectrl = (lastIdx_in == 1'b0 ? Delay3_out1 :
              numTotalBlobs_in);



  always @(posedge clk or posedge reset)
    begin : Delay3_lowered_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Delay3_ectrl;
        end
      end
    end



  assign numTotalBlobs_out = Delay3_out1;

endmodule  // gatheroutput

