// -------------------------------------------------------------
// 
// File Name: C:\Users\team06\Documents\MATLAB\Examples\R2022b\visionhdl\BlobAnalysisExample\verilog_hdl\BlobAnalysisHDL\Pixel_Stream_FIFO.v
// Created: 2022-12-23 11:30:02
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Pixel_Stream_FIFO
// Source Path: BlobAnalysisHDL/BlobDetector/CCA_Algorithm/Pixel Stream FIFO
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Pixel_Stream_FIFO
          (clk,
           reset,
           enb,
           pixelIn,
           ctrlIn_hStart,
           ctrlIn_hEnd,
           ctrlIn_vStart,
           ctrlIn_vEnd,
           ctrlIn_valid,
           pixelout,
           ctrlout_hStart,
           ctrlout_hEnd,
           ctrlout_vStart,
           ctrlout_vEnd,
           ctrlout_valid);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] pixelIn;  // uint8
  input   ctrlIn_hStart;
  input   ctrlIn_hEnd;
  input   ctrlIn_vStart;
  input   ctrlIn_vEnd;
  input   ctrlIn_valid;
  output  [7:0] pixelout;  // uint8
  output  ctrlout_hStart;
  output  ctrlout_hEnd;
  output  ctrlout_vStart;
  output  ctrlout_vEnd;
  output  ctrlout_valid;


  reg  ControlBalance_out1_hEnd;
  wire hEnd;
  wire hEnd_1;
  wire Logical_Operator1_out1;
  wire valid;
  wire hStart;
  wire vStart;
  wire Logical_Operator8_out1;
  wire vEnd;
  wire Logical_Operator_out1;
  wire Logical_Operator5_out1;
  reg  InFrame_out1;
  wire Logical_Operator4_out1;
  wire Logical_Operator3_out1;
  wire Logical_Operator6_out1;
  wire Logical_Operator11_out1;
  wire Logical_Operator13_out1;
  reg  InlLine_out1;
  wire Logical_Operator15_out1;
  wire Logical_Operator14_out1;
  wire Logical_Operator12_out1;
  wire Logical_Operator10_out1;
  wire Logical_Operator9_out1;
  wire Logical_Operator2_out1;
  wire Logical_Operator7_out1;
  wire InLineInFramePrev_out1;
  reg  InLineInFrameREG_out1;
  wire Logical_Operator1_out1_1;
  reg  ControlBalance_out1_vEnd;
  wire vEnd_1;
  wire Logical_Operator4_out1_1;
  wire Logical_Operator8_out1_1;
  reg  ControlBalance5_out1;
  reg  WriteCountLimit1_out1_hEnd;
  wire hEnd_2;
  wire [10:0] count_step;  // ufix11
  wire [10:0] count_reset;  // ufix11
  reg  hEnd_3;
  reg  ControlBalance_out1_hStart;
  wire hStart_1;
  reg  ControlBalance3_out1;
  wire Logical_Operator3_out1_1;
  wire hStart_2;
  reg  ControlBalance_out1_valid;
  wire valid_1;
  reg  ControlBalance2_out1;
  wire Logical_Operator6_out1_1;
  reg  ControlBalance1_out1;
  wire Logical_Operator5_out1_1;
  wire Logical_Operator7_out1_1;
  wire valid_2;
  wire [10:0] count_step_1;  // ufix11
  wire [10:0] count_reset_1;  // ufix11
  reg [10:0] Write_Counter_out1;  // ufix11
  wire [10:0] count;  // ufix11
  wire [10:0] count_1;  // ufix11
  wire [10:0] count_2;  // ufix11
  reg [10:0] WriteCountLimit_out1;  // ufix11
  wire [10:0] WriteCountLimit_ectrl;  // ufix11
  reg  ControlBalance_out1_vStart;
  wire vStart_1;
  reg  ControlBalance4_out1;
  wire Logical_Operator2_out1_1;
  reg  WriteCountLimit1_out1_vStart;
  wire vStart_2;
  reg [10:0] Read_Counter_out1;  // ufix11
  wire [10:0] count_3;  // ufix11
  reg  pop;
  wire [10:0] count_4;  // ufix11
  wire [10:0] count_5;  // ufix11
  reg  BufferState;  // ufix1
  reg  BufferState_next;  // ufix1
  reg  [0:2] Delay15_reg;  // ufix1 [3]
  wire [0:2] Delay15_reg_next;  // ufix1 [3]
  wire Delay15_out1;
  wire [7:0] Constant_out1;  // uint8
  reg [7:0] RAMDataIn_reg [0:2];  // ufix8 [3]
  wire [7:0] RAMDataIn_reg_next [0:2];  // ufix8 [3]
  wire [7:0] RAMDataIn_out1;  // uint8
  wire [7:0] y;  // uint8
  reg  Delay1_out1;
  reg [10:0] WriteCount_out1;  // ufix11
  wire [7:0] PixelRAM_out1;  // uint8
  wire [7:0] y_1;  // uint8
  reg [7:0] Delay12_out1;  // uint8
  wire [7:0] Switch_out1;  // uint8
  reg [7:0] Delay8_out1;  // uint8
  wire [4:0] Constant1_out1;  // ufix5
  reg  Delay2_out1;
  wire Data_Type_Conversion_out1;  // ufix1
  wire vStart_3;
  reg  ControlBalance6_out1;
  wire vEnd_2;
  wire Data_Type_Conversion1_out1;  // ufix1
  reg  Delay4_out1;
  wire Data_Type_Conversion2_out1;  // ufix1
  reg  Delay5_out1;
  wire Data_Type_Conversion3_out1;  // ufix1
  wire Data_Type_Conversion4_out1;  // ufix1
  wire [4:0] y_2;  // ufix5
  wire [4:0] ControlRAM_out1;  // ufix5
  reg [4:0] Delay13_out1;  // ufix5
  wire [4:0] Multiport_Switch_out1;  // ufix5
  wire Bit_Slice4_out1;  // ufix1
  wire Data_Type_Conversion8_out1;
  reg  Delay9_out1_hStart;
  wire Bit_Slice3_out1;  // ufix1
  wire Data_Type_Conversion7_out1;
  reg  Delay9_out1_hEnd;
  wire Bit_Slice2_out1;  // ufix1
  wire Data_Type_Conversion6_out1;
  reg  Delay9_out1_vStart;
  wire Bit_Slice1_out1;  // ufix1
  wire Data_Type_Conversion5_out1;
  reg  Delay9_out1_vEnd;
  wire Bit_Slice_out1;  // ufix1
  wire Data_Type_Conversion9_out1;
  reg  Delay9_out1_valid;


  always @(posedge clk or posedge reset)
    begin : c_process
      if (reset == 1'b1) begin
        ControlBalance_out1_hEnd <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance_out1_hEnd <= ctrlIn_hEnd;
        end
      end
    end



  assign hEnd = ControlBalance_out1_hEnd;

  assign hEnd_1 = ctrlIn_hEnd;

  assign Logical_Operator1_out1 =  ~ hEnd_1;



  assign valid = ctrlIn_valid;

  assign hStart = ctrlIn_hStart;

  assign vStart = ctrlIn_vStart;

  assign Logical_Operator8_out1 = vStart & (valid & hStart);



  assign vEnd = ctrlIn_vEnd;

  assign Logical_Operator_out1 =  ~ vEnd;



  assign Logical_Operator5_out1 = valid & vStart;



  assign Logical_Operator4_out1 = Logical_Operator_out1 & InFrame_out1;



  assign Logical_Operator3_out1 = Logical_Operator1_out1 & InFrame_out1;



  assign Logical_Operator6_out1 = Logical_Operator5_out1 | (Logical_Operator3_out1 | Logical_Operator4_out1);



  always @(posedge clk or posedge reset)
    begin : InFrame_process
      if (reset == 1'b1) begin
        InFrame_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          InFrame_out1 <= Logical_Operator6_out1;
        end
      end
    end



  assign Logical_Operator11_out1 =  ~ InFrame_out1;



  assign Logical_Operator13_out1 =  ~ valid;



  assign Logical_Operator15_out1 =  ~ InlLine_out1;



  assign Logical_Operator14_out1 = Logical_Operator15_out1 & (InFrame_out1 & (Logical_Operator_out1 & (valid & hStart)));



  assign Logical_Operator12_out1 = InlLine_out1 & Logical_Operator13_out1;



  assign Logical_Operator10_out1 = Logical_Operator11_out1 & InlLine_out1;



  assign Logical_Operator9_out1 = InlLine_out1 & vStart;



  assign Logical_Operator2_out1 = Logical_Operator1_out1 & InlLine_out1;



  assign Logical_Operator7_out1 = Logical_Operator14_out1 | (Logical_Operator12_out1 | (Logical_Operator10_out1 | (Logical_Operator9_out1 | (Logical_Operator2_out1 | Logical_Operator8_out1))));



  always @(posedge clk or posedge reset)
    begin : InlLine_process
      if (reset == 1'b1) begin
        InlLine_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          InlLine_out1 <= Logical_Operator7_out1;
        end
      end
    end



  assign InLineInFramePrev_out1 = InlLine_out1 & InFrame_out1;



  always @(posedge clk or posedge reset)
    begin : InLineInFrameREG_process
      if (reset == 1'b1) begin
        InLineInFrameREG_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          InLineInFrameREG_out1 <= InLineInFramePrev_out1;
        end
      end
    end



  assign Logical_Operator1_out1_1 = hEnd & InLineInFrameREG_out1;



  always @(posedge clk or posedge reset)
    begin : c_1_process
      if (reset == 1'b1) begin
        ControlBalance_out1_vEnd <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance_out1_vEnd <= ctrlIn_vEnd;
        end
      end
    end



  assign vEnd_1 = ControlBalance_out1_vEnd;

  assign Logical_Operator4_out1_1 = vEnd_1 & InLineInFrameREG_out1;



  assign Logical_Operator8_out1_1 = Logical_Operator1_out1_1 | Logical_Operator4_out1_1;



  always @(posedge clk or posedge reset)
    begin : ControlBalance5_process
      if (reset == 1'b1) begin
        ControlBalance5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance5_out1 <= Logical_Operator8_out1_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        WriteCountLimit1_out1_hEnd <= 1'b0;
      end
      else begin
        if (enb) begin
          WriteCountLimit1_out1_hEnd <= ControlBalance5_out1;
        end
      end
    end



  assign hEnd_2 = WriteCountLimit1_out1_hEnd;

  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  assign count_step = 11'b00000000001;



  assign count_reset = 11'b00000000000;



  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        hEnd_3 <= 1'b0;
      end
      else begin
        if (enb) begin
          hEnd_3 <= ControlBalance5_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : c_3_process
      if (reset == 1'b1) begin
        ControlBalance_out1_hStart <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance_out1_hStart <= ctrlIn_hStart;
        end
      end
    end



  assign hStart_1 = ControlBalance_out1_hStart;

  always @(posedge clk or posedge reset)
    begin : ControlBalance3_process
      if (reset == 1'b1) begin
        ControlBalance3_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance3_out1 <= hStart_1;
        end
      end
    end



  assign Logical_Operator3_out1_1 = ControlBalance3_out1 & InLineInFrameREG_out1;



  assign hStart_2 = Logical_Operator3_out1_1;

  always @(posedge clk or posedge reset)
    begin : c_4_process
      if (reset == 1'b1) begin
        ControlBalance_out1_valid <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance_out1_valid <= ctrlIn_valid;
        end
      end
    end



  assign valid_1 = ControlBalance_out1_valid;

  always @(posedge clk or posedge reset)
    begin : ControlBalance2_process
      if (reset == 1'b1) begin
        ControlBalance2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance2_out1 <= valid_1;
        end
      end
    end



  assign Logical_Operator6_out1_1 = ControlBalance2_out1 & InLineInFrameREG_out1;



  always @(posedge clk or posedge reset)
    begin : ControlBalance1_process
      if (reset == 1'b1) begin
        ControlBalance1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance1_out1 <= InLineInFrameREG_out1;
        end
      end
    end



  assign Logical_Operator5_out1_1 = ControlBalance1_out1 & ControlBalance2_out1;



  assign Logical_Operator7_out1_1 = Logical_Operator6_out1_1 | Logical_Operator5_out1_1;



  assign valid_2 = Logical_Operator7_out1_1;

  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  assign count_step_1 = 11'b00000000001;



  assign count_reset_1 = 11'b00000000000;



  assign count = Write_Counter_out1 + count_step_1;



  assign count_1 = (valid_2 == 1'b0 ? Write_Counter_out1 :
              count);



  assign count_2 = (hStart_2 == 1'b0 ? count_1 :
              count_reset_1);



  always @(posedge clk or posedge reset)
    begin : Write_Counter_process
      if (reset == 1'b1) begin
        Write_Counter_out1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          Write_Counter_out1 <= count_2;
        end
      end
    end



  assign WriteCountLimit_ectrl = (hEnd_3 == 1'b0 ? WriteCountLimit_out1 :
              Write_Counter_out1);



  always @(posedge clk or posedge reset)
    begin : WriteCountLimit_lowered_process
      if (reset == 1'b1) begin
        WriteCountLimit_out1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          WriteCountLimit_out1 <= WriteCountLimit_ectrl;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : c_5_process
      if (reset == 1'b1) begin
        ControlBalance_out1_vStart <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance_out1_vStart <= ctrlIn_vStart;
        end
      end
    end



  assign vStart_1 = ControlBalance_out1_vStart;

  always @(posedge clk or posedge reset)
    begin : ControlBalance4_process
      if (reset == 1'b1) begin
        ControlBalance4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance4_out1 <= vStart_1;
        end
      end
    end



  assign Logical_Operator2_out1_1 = ControlBalance4_out1 & InLineInFrameREG_out1;



  always @(posedge clk or posedge reset)
    begin : c_6_process
      if (reset == 1'b1) begin
        WriteCountLimit1_out1_vStart <= 1'b0;
      end
      else begin
        if (enb) begin
          WriteCountLimit1_out1_vStart <= Logical_Operator2_out1_1;
        end
      end
    end



  assign vStart_2 = WriteCountLimit1_out1_vStart;

  assign count_3 = Read_Counter_out1 + count_step;



  assign count_4 = (pop == 1'b0 ? Read_Counter_out1 :
              count_3);



  assign count_5 = (ControlBalance5_out1 == 1'b0 ? count_4 :
              count_reset);



  always @(posedge clk or posedge reset)
    begin : Read_Counter_process
      if (reset == 1'b1) begin
        Read_Counter_out1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          Read_Counter_out1 <= count_5;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : visionhdlutilities_c2_Memory_Controller_process
      if (reset == 1'b1) begin
        BufferState <= 1'b0;
      end
      else begin
        if (enb) begin
          BufferState <= BufferState_next;
        end
      end
    end

  always @(BufferState, Read_Counter_out1, WriteCountLimit_out1, hEnd_2, vStart_2) begin
    BufferState_next = BufferState;
    // Copyright 2017-2021 The MathWorks, Inc.
    case ( BufferState)
      1'b0 :
        begin
          //%% Idle State
          pop = 1'b0;
          if (hEnd_2) begin
            BufferState_next = 1'b1;
          end
          else begin
            BufferState_next = 1'b0;
          end
        end
      1'b1 :
        begin
          //%% Pop until limit reached
          pop = 1'b1;
          if ((Read_Counter_out1 == WriteCountLimit_out1) || vStart_2) begin
            BufferState_next = 1'b0;
          end
          else begin
            BufferState_next = 1'b1;
          end
        end
      default :
        begin
          pop = 1'b0;
        end
    endcase
  end



  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        Delay15_reg[0] <= 1'b0;
        Delay15_reg[1] <= 1'b0;
        Delay15_reg[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay15_reg[0] <= Delay15_reg_next[0];
          Delay15_reg[1] <= Delay15_reg_next[1];
          Delay15_reg[2] <= Delay15_reg_next[2];
        end
      end
    end

  assign Delay15_out1 = Delay15_reg[2];
  assign Delay15_reg_next[0] = pop;
  assign Delay15_reg_next[1] = Delay15_reg[0];
  assign Delay15_reg_next[2] = Delay15_reg[1];



  assign Constant_out1 = 8'b00000000;



  always @(posedge clk or posedge reset)
    begin : RAMDataIn_process
      if (reset == 1'b1) begin
        RAMDataIn_reg[0] <= 8'b00000000;
        RAMDataIn_reg[1] <= 8'b00000000;
        RAMDataIn_reg[2] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          RAMDataIn_reg[0] <= RAMDataIn_reg_next[0];
          RAMDataIn_reg[1] <= RAMDataIn_reg_next[1];
          RAMDataIn_reg[2] <= RAMDataIn_reg_next[2];
        end
      end
    end

  assign RAMDataIn_out1 = RAMDataIn_reg[2];
  assign RAMDataIn_reg_next[0] = pixelIn;
  assign RAMDataIn_reg_next[1] = RAMDataIn_reg[0];
  assign RAMDataIn_reg_next[2] = RAMDataIn_reg[1];



  // Copyright 2017-2021 The MathWorks, Inc.
  assign y = RAMDataIn_out1;



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= valid_2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : WriteCount_process
      if (reset == 1'b1) begin
        WriteCount_out1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          WriteCount_out1 <= Read_Counter_out1;
        end
      end
    end



  SimpleDualPortRAM_generic_block #(.AddrWidth(11),
                                    .DataWidth(8)
                                    )
                                  u_PixelRAM (.clk(clk),
                                              .enb(enb),
                                              .wr_din(y),
                                              .wr_addr(Write_Counter_out1),
                                              .wr_en(Delay1_out1),
                                              .rd_addr(WriteCount_out1),
                                              .rd_dout(PixelRAM_out1)
                                              );

  // Copyright 2017-2021 The MathWorks, Inc.
  assign y_1 = PixelRAM_out1;



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= y_1;
        end
      end
    end



  assign Switch_out1 = (Delay15_out1 == 1'b0 ? Constant_out1 :
              Delay12_out1);



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= Switch_out1;
        end
      end
    end



  assign pixelout = Delay8_out1;

  assign Constant1_out1 = 5'b00000;



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= hStart_2;
        end
      end
    end



  assign Data_Type_Conversion_out1 = Delay2_out1;



  assign vStart_3 = Logical_Operator2_out1_1;

  always @(posedge clk or posedge reset)
    begin : ControlBalance6_process
      if (reset == 1'b1) begin
        ControlBalance6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          ControlBalance6_out1 <= Logical_Operator4_out1_1;
        end
      end
    end



  assign vEnd_2 = ControlBalance6_out1;

  assign Data_Type_Conversion1_out1 = hEnd_3;



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= vStart_3;
        end
      end
    end



  assign Data_Type_Conversion2_out1 = Delay4_out1;



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= vEnd_2;
        end
      end
    end



  assign Data_Type_Conversion3_out1 = Delay5_out1;



  assign Data_Type_Conversion4_out1 = Delay1_out1;



  assign y_2 = {Data_Type_Conversion_out1, Data_Type_Conversion1_out1, Data_Type_Conversion2_out1, Data_Type_Conversion3_out1, Data_Type_Conversion4_out1};



  SimpleDualPortRAM_generic #(.AddrWidth(11),
                              .DataWidth(5)
                              )
                            u_ControlRAM (.clk(clk),
                                          .enb(enb),
                                          .wr_din(y_2),
                                          .wr_addr(Write_Counter_out1),
                                          .wr_en(Delay1_out1),
                                          .rd_addr(WriteCount_out1),
                                          .rd_dout(ControlRAM_out1)
                                          );

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 5'b00000;
      end
      else begin
        if (enb) begin
          Delay13_out1 <= ControlRAM_out1;
        end
      end
    end



  assign Multiport_Switch_out1 = (Delay15_out1 == 1'b0 ? Constant1_out1 :
              Delay13_out1);



  assign Bit_Slice4_out1 = Multiport_Switch_out1[4];



  assign Data_Type_Conversion8_out1 = (Bit_Slice4_out1 != 1'b0 ? 1'b1 :
              1'b0);



  always @(posedge clk or posedge reset)
    begin : c_7_process
      if (reset == 1'b1) begin
        Delay9_out1_hStart <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1_hStart <= Data_Type_Conversion8_out1;
        end
      end
    end



  assign ctrlout_hStart = Delay9_out1_hStart;

  assign Bit_Slice3_out1 = Multiport_Switch_out1[3];



  assign Data_Type_Conversion7_out1 = (Bit_Slice3_out1 != 1'b0 ? 1'b1 :
              1'b0);



  always @(posedge clk or posedge reset)
    begin : c_8_process
      if (reset == 1'b1) begin
        Delay9_out1_hEnd <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1_hEnd <= Data_Type_Conversion7_out1;
        end
      end
    end



  assign ctrlout_hEnd = Delay9_out1_hEnd;

  assign Bit_Slice2_out1 = Multiport_Switch_out1[2];



  assign Data_Type_Conversion6_out1 = (Bit_Slice2_out1 != 1'b0 ? 1'b1 :
              1'b0);



  always @(posedge clk or posedge reset)
    begin : c_9_process
      if (reset == 1'b1) begin
        Delay9_out1_vStart <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1_vStart <= Data_Type_Conversion6_out1;
        end
      end
    end



  assign ctrlout_vStart = Delay9_out1_vStart;

  assign Bit_Slice1_out1 = Multiport_Switch_out1[1];



  assign Data_Type_Conversion5_out1 = (Bit_Slice1_out1 != 1'b0 ? 1'b1 :
              1'b0);



  always @(posedge clk or posedge reset)
    begin : c_10_process
      if (reset == 1'b1) begin
        Delay9_out1_vEnd <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1_vEnd <= Data_Type_Conversion5_out1;
        end
      end
    end



  assign ctrlout_vEnd = Delay9_out1_vEnd;

  assign Bit_Slice_out1 = Multiport_Switch_out1[0];



  assign Data_Type_Conversion9_out1 = (Bit_Slice_out1 != 1'b0 ? 1'b1 :
              1'b0);



  always @(posedge clk or posedge reset)
    begin : c_11_process
      if (reset == 1'b1) begin
        Delay9_out1_valid <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1_valid <= Data_Type_Conversion9_out1;
        end
      end
    end



  assign ctrlout_valid = Delay9_out1_valid;

endmodule  // Pixel_Stream_FIFO

