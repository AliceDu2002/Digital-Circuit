// -------------------------------------------------------------
// 
// File Name: C:\Users\team06\Documents\MATLAB\Examples\R2022b\visionhdl\BlobAnalysisExample\verilog_hdl\BlobAnalysisHDL\DATA_MEMORY.v
// Created: 2022-12-23 11:30:02
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: DATA_MEMORY
// Source Path: BlobAnalysisHDL/BlobDetector/CCA_Algorithm/Closing/LineBuffer/DATA_MEMORY
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module DATA_MEMORY
          (clk,
           reset,
           enb,
           Unloading,
           pixelIn,
           hStartIn,
           hEndIn,
           validIn,
           popEn,
           dataVectorOut_0,
           dataVectorOut_1,
           dataVectorOut_2,
           dataVectorOut_3,
           popOut,
           AllAtEnd);


  input   clk;
  input   reset;
  input   enb;
  input   Unloading;
  input   pixelIn;
  input   hStartIn;
  input   hEndIn;
  input   validIn;
  input   [1:0] popEn;  // ufix2
  output  dataVectorOut_0;  // boolean
  output  dataVectorOut_1;  // boolean
  output  dataVectorOut_2;  // boolean
  output  dataVectorOut_3;  // boolean
  output  popOut;
  output  AllAtEnd;


  reg  [0:3] intdelay_reg;  // ufix1 [4]
  wire [0:3] intdelay_reg_next;  // ufix1 [4]
  wire pixelColumn_0;
  reg  validREG;
  reg  unloadPop;
  reg  hEndREG;
  reg  hEndREGT;
  wire unloadPopT;
  wire validPop;
  wire PopEnSL;
  wire [10:0] writeAddr1;  // ufix11
  wire pushFIFO2;
  wire [10:0] readAddr2;  // ufix11
  wire popFIFO_2;
  wire EndofLine1;
  reg [10:0] writeAddrREG1;  // ufix11
  reg  pushOutREG1;
  wire pixelColumn1;
  wire PopEnSL_1;
  wire [10:0] writeAddr2;  // ufix11
  wire pushFIFO3;
  wire [10:0] readAddr3;  // ufix11
  wire EndofLine2;
  reg [10:0] writeAddrREG2;  // ufix11
  reg  pushOutREG2;
  wire pixelColumn2;
  wire PopEnSL_2;
  wire [10:0] writeAddr3;  // ufix11
  wire pushFIFO4;
  wire [10:0] readAddr4;  // ufix11
  wire EndofLine3;
  reg [10:0] writeAddrREG3;  // ufix11
  reg  pushOutREG3;
  wire pixelColumn3;
  reg  popOut_1;


  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
        end
      end
    end

  assign pixelColumn_0 = intdelay_reg[3];
  assign intdelay_reg_next[0] = pixelIn;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];



  assign dataVectorOut_0 = pixelColumn_0;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        validREG <= 1'b0;
      end
      else begin
        if (enb) begin
          validREG <= validIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        unloadPop <= 1'b0;
      end
      else begin
        if (enb) begin
          unloadPop <= validREG;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        hEndREG <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndREG <= hEndIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        hEndREGT <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndREGT <= hEndREG;
        end
      end
    end



  assign unloadPopT = hEndREGT & (unloadPop & Unloading);



  assign validPop = validREG | unloadPopT;



  assign PopEnSL = popEn[0];



  PushPopCounterOne u_PushPopCounterOne (.clk(clk),
                                         .reset(reset),
                                         .enb(enb),
                                         .hStartIn(hStartIn),
                                         .popIn(validPop),
                                         .popEnable(PopEnSL),
                                         .hEndIn(hEndREG),
                                         .wrAddr(writeAddr1),  // ufix11
                                         .pushOut(pushFIFO2),
                                         .rdAddr(readAddr2),  // ufix11
                                         .popOut(popFIFO_2),
                                         .EndofLine(EndofLine1)
                                         );

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        writeAddrREG1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          writeAddrREG1 <= writeAddr1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        pushOutREG1 <= 1'b0;
      end
      else begin
        if (enb) begin
          pushOutREG1 <= pushFIFO2;
        end
      end
    end



  SimpleDualPortRAM_singlebit #(.AddrWidth(11),
                                .DataWidth(1)
                                )
                              u_SimpleDualPortRAM_Generic1_singlebit (.clk(clk),
                                                                      .enb(enb),
                                                                      .wr_din(pixelColumn_0),
                                                                      .wr_addr(writeAddrREG1),
                                                                      .wr_en(pushOutREG1),
                                                                      .rd_addr(readAddr2),
                                                                      .rd_dout(pixelColumn1)
                                                                      );

  assign dataVectorOut_1 = pixelColumn1;

  assign PopEnSL_1 = popEn[1];



  PushPopCounter u_PushPopCounter2 (.clk(clk),
                                    .reset(reset),
                                    .enb(enb),
                                    .hStartIn(hStartIn),
                                    .popIn(validPop),
                                    .popEnable(PopEnSL_1),
                                    .hEndIn(hEndREG),
                                    .writeCountPrev(writeAddr1),  // ufix11
                                    .wrAddr(writeAddr2),  // ufix11
                                    .pushOut(pushFIFO3),
                                    .rdAddr(readAddr3),  // ufix11
                                    .EndofLine(EndofLine2)
                                    );

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_6_process
      if (reset == 1'b1) begin
        writeAddrREG2 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          writeAddrREG2 <= writeAddr2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_7_process
      if (reset == 1'b1) begin
        pushOutREG2 <= 1'b0;
      end
      else begin
        if (enb) begin
          pushOutREG2 <= pushFIFO3;
        end
      end
    end



  SimpleDualPortRAM_singlebit #(.AddrWidth(11),
                                .DataWidth(1)
                                )
                              u_SimpleDualPortRAM_Generic2 (.clk(clk),
                                                            .enb(enb),
                                                            .wr_din(pixelColumn1),
                                                            .wr_addr(writeAddrREG2),
                                                            .wr_en(pushOutREG2),
                                                            .rd_addr(readAddr3),
                                                            .rd_dout(pixelColumn2)
                                                            );

  assign dataVectorOut_2 = pixelColumn2;

  assign PopEnSL_2 = popEn[1];



  PushPopCounter u_PushPopCounter3 (.clk(clk),
                                    .reset(reset),
                                    .enb(enb),
                                    .hStartIn(hStartIn),
                                    .popIn(validPop),
                                    .popEnable(PopEnSL_2),
                                    .hEndIn(hEndREG),
                                    .writeCountPrev(writeAddr2),  // ufix11
                                    .wrAddr(writeAddr3),  // ufix11
                                    .pushOut(pushFIFO4),
                                    .rdAddr(readAddr4),  // ufix11
                                    .EndofLine(EndofLine3)
                                    );

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_8_process
      if (reset == 1'b1) begin
        writeAddrREG3 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          writeAddrREG3 <= writeAddr3;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_9_process
      if (reset == 1'b1) begin
        pushOutREG3 <= 1'b0;
      end
      else begin
        if (enb) begin
          pushOutREG3 <= pushFIFO4;
        end
      end
    end



  SimpleDualPortRAM_singlebit #(.AddrWidth(11),
                                .DataWidth(1)
                                )
                              u_SimpleDualPortRAM_Generic3 (.clk(clk),
                                                            .enb(enb),
                                                            .wr_din(pixelColumn2),
                                                            .wr_addr(writeAddrREG3),
                                                            .wr_en(pushOutREG3),
                                                            .rd_addr(readAddr4),
                                                            .rd_dout(pixelColumn3)
                                                            );

  assign dataVectorOut_3 = pixelColumn3;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_10_process
      if (reset == 1'b1) begin
        popOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          popOut_1 <= popFIFO_2;
        end
      end
    end



  assign AllAtEnd = EndofLine3 & (EndofLine1 & EndofLine2);



  assign popOut = popOut_1;

endmodule  // DATA_MEMORY

